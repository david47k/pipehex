/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* Copyright 2022 David Atkinson */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n\tFPS: 30,\n});\n\n\n//# sourceURL=webpack://pipehex/./src/config.js?");

/***/ }),

/***/ "./src/game-manager.js":
/*!*****************************!*\
  !*** ./src/game-manager.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameManager\": () => (/* binding */ GameManager),\n/* harmony export */   \"gameManager\": () => (/* binding */ gameManager)\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"./src/config.js\");\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view.js */ \"./src/view.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storage.js */ \"./src/storage.js\");\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./timer.js */ \"./src/timer.js\");\n/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tile.js */ \"./src/tile.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./game.js */ \"./src/game.js\");\n/* game-manager.js\n * Manages the game, other components, takes interaction with the player.\n * Copyright 2022 David Atkinson <david47k@d47.co>\n */\n\n\n\n\n\n\n\n\n\n/** @param {number} n */\nfunction rand_inclusive(n) {\n\treturn Math.trunc(Math.random() * (n+1));\n}\n\n\n/** @typedef {{width: number, height: number, grid: null | Tile[][], solvedGrid: null|Tile[][], won: boolean, title: string, timer: any }} GameLike */\n\n// destructuring alternative. overwrites the default values we've already assigned.\n// for(const [key, value] of Object.entries(params)) {\n//   Object.defineProperty(this, key, { value: value, writable: true });\n// }\n\n// destructuring alternative. uses params if provided, otherwise uses defaultParams\n// for(const [key, value] of Object.entries(defaultParams)) {\n//   if(params.hasOwn(key) Object.defineProperty(this, key, { value: Object.getOwnPropertyDescriptor(params, key), writable: true });\n//\t else Object.defineProperty(this, key, { value: value, writable: true });\n// }\n\n\n\n/** @param {string} filename\n *  @param {function(Array<string>):void} onloadfn */\n function readFile(filename, onloadfn) {\n    const oReq = new XMLHttpRequest();\n    oReq.open(\"GET\", filename, true);\n    oReq.responseType = \"text\";\n    oReq.onload = function(oEvent) {\n\t\tconst t = oReq.response;\n\t\tconsole.log(\"puzzle file loaded: \",filename);\n\t\t// parse CSV into lines\n\t\t/** @type { Array<string> } */\n\t\tlet puzzleArr = [];\n\t\tlet lines = t.split(\"\\n\");\n\t\tfor(let l of lines) {\n\t\t\tif(l.length>8) puzzleArr.push(l);\n\t\t}\n        onloadfn(puzzleArr);\n    };\n    oReq.send(null);\n}\n\n\nclass GameManager {\n\tconstructor() {\n\t\t/** @type {Map<string,Array<string>>} */\n\t\tthis.PUZZLES = new Map();\n\t\t/** @type {string} */\n\t\tthis.puzzleType = _storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadStr('puzzleType','5');\n\t\tthis.puzzleIdx = _storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadInt('puzzleIdx'+this.puzzleType,0);\n\t\tthis.showStats = false;\n\t\tthis.showFPS = false;\n\t\tthis.showTimer = true;\n\t\tthis.showSettings = false;\n\t\t\n\t\treadFile('/puzzles5.csv', a => this.PUZZLES.set('5', a));\n\t\treadFile('/puzzles10.csv', a => this.PUZZLES.set('10', a ));\n\t\treadFile('/puzzles15.csv', a => this.PUZZLES.set('15', a ));\n\t\treadFile('/puzzles20.csv', a => this.PUZZLES.set('20', a ));\n\t\treadFile('/puzzles30.csv', a => this.PUZZLES.set('30', a ));\n\t\treadFile('/puzzles40.csv', a => this.PUZZLES.set('40', a ));\n\n\t\tthis.renderSet = new Set();\n\t\tthis.loopedSet = new Set();\n\t\tthis.game = this.loadGame(parseInt(this.puzzleType));\n\t\tthis.updateStats();\n\t\t\n\t\tthis.view = new _view_js__WEBPACK_IMPORTED_MODULE_1__.View(this.game.width,this.game.height);\n\n\t\tthis.restart({restartSolved:false, restartGame:false});\n\n\t\tthis.view.container.addEventListener('contextmenu', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\treturn false;\n\t\t});\n\t\tthis.view.container.addEventListener('click', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t\tev.stopImmediatePropagation();\n\t\t\treturn false;\n\t\t});\n\t\tthis.view.container.addEventListener('mouseup', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t\tev.stopImmediatePropagation();\n\t\t\treturn false;\n\t\t});\t\t\t\n\t\tthis.view.container.addEventListener('mousedown', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t\tev.stopImmediatePropagation();\n\t\t\tvar gm = gameManager;\n\t\t\tvar [x, y] = gm.game.xyFromPixelCoords(ev.offsetX, ev.offsetY);\n\t\t\tif(gm.game.inBounds(x,y)) {\n\t\t\t\tgm.click(x,y,ev.buttons);\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n\tprevPuzzle() {\n\t\tif(this.puzzleIdx <= 0) {\n\t\t\tconsole.log(\"No previous puzzles!\");\n\t\t} else {\n\t\t\tthis.puzzleIdx--;\n\t\t\t_storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].saveInt('puzzleIdx'+this.puzzleType,this.puzzleIdx);\n\t\t\tthis.restart();\n\t\t}\n\t}\n\tnextPuzzle() {\n\t\tif(this.puzzleIdx + 1 >= this.PUZZLES.get(this.puzzleType).length) {\n\t\t\tconsole.log(\"Ran out of puzzles!\");\n\t\t} else {\n\t\t\tthis.puzzleIdx++;\n\t\t\t_storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].saveInt('puzzleIdx'+this.puzzleType,this.puzzleIdx);\n\t\t\tthis.restart();\n\t\t}\n\t}\n\trestart({restartSolved = false, restartGame = true}={}) {\t\n\t\t// check if we have finished loading the puzzle data, if not, try again later.\n\t\tif(!this.PUZZLES.has(this.puzzleType)) {\n\t\t\tsetTimeout(() => gameManager.restart({restartSolved:restartSolved, restartGame:restartGame}), 100);\n\t\t\treturn;\n\t\t}\n\n\t\tif(restartGame || this.game.width==0) {\n\t\t\tconst n = parseInt(this.puzzleType);\n\t\t\tthis.game = new _game_js__WEBPACK_IMPORTED_MODULE_6__.Game({width:n,height:n});\n\t\t\tthis.game.loadLevelString(this.PUZZLES.get(this.puzzleType)[this.puzzleIdx]);\n\t\t}\n\t\t\n\t\t// if the game has been solved, actually load the solved puzzle, and set win condition\n\t\tif(!restartSolved) {\n\t\t\tlet hs = _storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadMap('highscore'+this.puzzleType, new Map());\n\t\t\tlet t = parseInt(hs.get(this.puzzleIdx));\n\t\t\tif(Number.isInteger(t)) {\n\t\t\t\tthis.game.grid = this.game.solvedGrid;\n\t\t\t\tthis.game.timer = new _timer_js__WEBPACK_IMPORTED_MODULE_3__.Timer({time: t});\n\t\t\t\tif(this.game.haveWinCondition()) {\n\t\t\t\t\tthis.onWin();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set up the view, and set all tiles to be rendered\n\t\tif(this.view) {\n\t\t\tthis.view.setUp(this.game.width,this.game.height);\n\t\t\tthis.paintAll();\n\t\t}\n\t\t\n\t\t// save the game state\n\t\tthis.saveGame();\n\t}\n\t/** @param {number} n */\n\tsetSize(n) {\n\t\tthis.puzzleType = n.toString();\n\t\t_storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].saveStr('puzzleType',this.puzzleType);\n\t\tthis.puzzleIdx = _storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadInt('puzzleIdx'+this.puzzleType,0);\n\t\tthis.updateStats();\n\t\tthis.restart();\n\t}\n\tupdateLoopSet() {\n\t\tconst prevSet = this.loopedSet;\n\t\tthis.loopedSet = new Set();\n\t\t// TO DO: have a more efficient mode, where we only look at tiles surounding the clicked tile\n\n\t\tlet tiles = [];\n\t\tfor(let n=0;n<(this.game.height*this.game.width);n++) {\n\t\t\ttiles.push(n);\n\t\t}\n\t\t\n\t\twhile(tiles.length > 0) {\n\t\t\tlet idx = tiles.pop();\n\t\t\tif(idx==-1) continue;\n\t\t\tlet [tx, ty] = this.game.xyFromIdx(idx);\n\t\t\tlet [tileSet, loopedSet] = this.game.getConnectedTiles(tx,ty,true);\n\t\t\tfor (const ti of tileSet) {\n\t\t\t\tlet midx = tiles.findIndex( el => el === ti );\n\t\t\t\tif(midx != -1) {\n\t\t\t\t\ttiles[midx] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(const lt of loopedSet) {\n\t\t\t\t//console.log('lt',lt);\n\t\t\t\tthis.loopedSet.add(lt);\n\t\t\t}\n\t\t}\n\t\t// we need to render everything that has changed between prevSet and loopedSet\n\t\t// ie. anything exclusive to one set, but not anything that is in both\n\t\tfor(const psi of prevSet) {\n\t\t\tif(!this.loopedSet.has(psi)) {\n\t\t\t\tthis.renderSet.add(psi);\n\t\t\t}\n\t\t}\n\t\tfor(const lsi of this.loopedSet) {\n\t\t\tif(!prevSet.has(lsi)) {\n\t\t\t\tthis.renderSet.add(lsi);\n\t\t\t}\n\t\t}\n\t}\n\t/** @param {number} ts */\n\trender(ts) {\n\t\tthis.game.ts = ts;\n\t\tthis.game.timer.update(ts);\n\t\t\n\t\t// check for a change\n\t\tif(this.renderSet.size > 0) {\n\t\t\t// locate loops, in the whole puzzle\n\t\t\tthis.updateLoopSet();\n\t\t}\n\t\t\n\t\tthis.view.render();\n\t}\n\tpaintAll() {\n\t\t// note: paintAll does not call render(), render will be called by the animationFrame main() loop\n\t\tthis.renderSet = new Set();\n\t\tthis.loopedSet = new Set();\n\t\tthis.updateLoopSet();\n\t\tfor(let i=0;i<(this.game.height*this.game.width);i++) {\n\t\t\tthis.renderSet.add(i);\n\t\t}\n\t}\n\tsaveGame() {\n\t\t_storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].saveObj('savegame',this.game);\n\t}\n\t/** @param {number} n */\n\tloadGame(n) {\n\t\t// will return a fully loaded game, or just a dummy game\n\t\tthis.showTimer = (_storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadStr('showTimer','true') === 'true');\n\t\tthis.showFPS = (_storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadStr('showFPS','false') === 'true');\n\t\tlet loaded = _storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadObj('savegame',{width:0,height:0});\n\t\treturn new _game_js__WEBPACK_IMPORTED_MODULE_6__.Game(loaded);\n\t}\n\tupdateStats() {\n\t\t/** @type {Array<number>} */\n\t\tlet hsmap = _storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadMap('highscore'+this.puzzleType, new Map());\n\t\tlet hs = [ ...hsmap.values() ];\n\t\ths.sort((a, b) => a - b);\n\t\tlet puztype = this.puzzleType + 'x' + this.puzzleType;\n\t\tlet best = 'tbd';\n\t\tlet best3 = 'tbd';\n\t\tlet best5 = 'tbd';\n\t\tlet best10 = 'tbd'\n\t\tif(hs.length>=1)  best = (0,_timer_js__WEBPACK_IMPORTED_MODULE_3__.timestringFrom)(hs[0]);\n\t\tif(hs.length>=3)  best3 = (0,_timer_js__WEBPACK_IMPORTED_MODULE_3__.timestringFrom)(hs.slice(0,3).reduce( (p, c) => p + c, 0 )/3.0);\n\t\tif(hs.length>=5)  best5 = (0,_timer_js__WEBPACK_IMPORTED_MODULE_3__.timestringFrom)(hs.slice(0,5).reduce( (p, c) => p + c, 0 )/5.0);\n\t\tif(hs.length>=10) best10 = (0,_timer_js__WEBPACK_IMPORTED_MODULE_3__.timestringFrom)(hs.slice(0,10).reduce( (p, c) => p + c, 0 )/10.0);\n\t\tthis.stats = { puztype: puztype, num: hs.length.toString(), best: best, best3: best3, best5: best5, best10: best10 };\n\t}\n\tonWin() {\n\t\tthis.game.timer.stop(this.game.tsPrior);\n\t\tthis.game.wintime = this.game.timer.timestring();\n\t\tdocument.getElementById('wintime').innerHTML = this.game.wintime;\n\t\tlet hs = _storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadMap('highscore'+this.puzzleType, new Map());\n\t\ths.set(this.puzzleIdx, Math.trunc(this.game.timer.getMillis()));\n\t\t_storage_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].saveMap('highscore'+this.puzzleType,hs);\n\t\tthis.updateStats();\n\t\tif(this.game.winningAnimation.started == false) {\n\t\t\t\tthis.game.winningAnimation.started = true;\n\t\t\t\tthis.game.winningAnimation.start_ts = this.game.ts;\n\t\t}\n\t}\n\t/** @param {number} x\n\t *  @param {number} y\n\t *  @param {number} buttons */\n\tclick(x,y,buttons) {\n\t\tif(!this.game.won) {\n\t\t\tif(buttons==0 || buttons==1) this.game.grid[y][x].rotate();\n\t\t\telse if(buttons==2) this.game.grid[y][x].rotate(true);\n\t\t\tthis.renderSet.add(this.game.idxFromXy(x,y));\n\t\t\tthis.game.timer.start(this.game.tsPrior);\n\t\t\t// check if we need to change colours of surrounding tiles\n\t\t\tlet surrounding_tiles = this.game.getSurroundingTiles(x,y);\n\t\t\twhile(surrounding_tiles.length > 0) {\n\t\t\t\tlet [nx,ny] = surrounding_tiles.pop();\n\t\t\t\tif(this.game.isIsolated(nx,ny)) {\n\t\t\t\t\tif(this.game.grid[ny][nx].isolated == false) {\n\t\t\t\t\t\tthis.game.grid[ny][nx].isolated = true;\n\t\t\t\t\t\tthis.game.grid[ny][nx].color = _view_js__WEBPACK_IMPORTED_MODULE_1__.PALETTE_ANNEX;\n\t\t\t\t\t\tthis.renderSet.add(this.game.idxFromXy(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(this.game.grid[ny][nx].isolated == true) {\n\t\t\t\t\t\tthis.renderSet.add(this.game.idxFromXy(nx,ny));\n\t\t\t\t\t\tthis.game.grid[ny][nx].isolated = false;\n\t\t\t\t\t\t// it'll get a color below, now it is no longer isolated\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check if we are connected to any tiles, in which case we need to change colors\n\t\t\tlet [tileSet,loopedSet] = this.game.getConnectedTiles(x,y,true);\n\t\t\tlet colorIdx = this.game.grid[y][x].color;\n\t\t\tif(tileSet.size <= 1) {\n\t\t\t\tthis.game.grid[y][x].isolated = true;\n\t\t\t\tcolorIdx = _view_js__WEBPACK_IMPORTED_MODULE_1__.PALETTE_ANNEX;\n\t\t\t} else {\n\t\t\t\tthis.game.grid[y][x].isolated = false;\n\t\t\t\t\n\t\t\t\tlet iter = tileSet.values();\n\t\t\t\titer.next();\n\t\t\t\tlet cxy = iter.next().value;\t\t// change the color to the SECOND item in the set\n\t\t\t\tcolorIdx = this.game.tileFromIdx(cxy).color;\n\t\t\t\tif(colorIdx==_view_js__WEBPACK_IMPORTED_MODULE_1__.PALETTE_ANNEX) {\n\t\t\t\t\tcolorIdx = ((y*this.game.width+x)%(_view_js__WEBPACK_IMPORTED_MODULE_1__.PALETTE.length));\t// randomish color\n\t\t\t\t\t// TODO: should ideally pick a colour that is dissimilar to surrounding colours\n\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log('tileSet size:',tileSet.size);\n\t\t\tfor(let v of tileSet) {\n\t\t\t\tlet tsy = Math.trunc(v/this.game.width);\n\t\t\t\tlet tsx = v%this.game.width;\n\t\t\t\tif(this.game.grid[tsy][tsx].color != colorIdx) {\n\t\t\t\t\tthis.game.grid[tsy][tsx].color = colorIdx;\n\t\t\t\t\tthis.renderSet.add(v);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif(this.game.haveWinCondition()) {\n\t\t\t\tthis.onWin();\n\t\t\t}\n\t\t}\t\t\n\t\tthis.render(this.game.ts); // render straight away without waiting for animationFrame\n\t\tthis.saveGame();\t\t\n\t}\n}\n\n// Global export\n\nvar gameManager = new GameManager();    // global scope\n// window.gameManager = new GameManager(); roughly equivalent to this\n\n\n//# sourceURL=webpack://pipehex/./src/game-manager.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ \"./src/timer.js\");\n/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tile.js */ \"./src/tile.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n/* game.js\n * The game/puzzle, loading methods, game state, interactions etc.\n * Copyright 2022 David Atkinson <david47k@d47.co>\n */\n\n\n\n\n\nconst BASE = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_-';\n\nclass Game {\n\t/** @constructor\n\t *  @param {object} params\n\t * */\n\t//constructor({ width=0, height=0, grid = null, solvedGrid = null, won = false, title = '(puzzle title)', timer = {time:0} } = {}) {\n\tconstructor(params = {}) {\n\t\t// these are the defaults, and will be used if not overriden by params\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\t/** @type {Tile[][]|null} */\n\t\tthis.grid =  null;\n\t\t/** @type {Tile[][]|null} */\n\t\tthis.solvedGrid = null;\n\t\tthis.won = false;\n\t\tthis.title = '(puzzle title)';\n\t\tthis.timer = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer();\n\t\tthis.wintime  ='';\n\t\t\n\t\t// this is a funny way of avoiding jsdoc/ts destructuring type issues\n\t\tfor(const [key, value] of Object.entries(params)) {\n\t\t\tif(params.hasOwnProperty(key)) Object.defineProperty(this, key, { value: Object.getOwnPropertyDescriptor(params, key).value, writable: true });\n\t\t}\n\n\t\t// re-juice these objects with the correct type\n\t\tthis.grid = this.newGrid(this.grid);\n\t\tthis.timer = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer(this.timer);\n\t\t\n\t\t// these values will override anything passed to us\n\t\tthis.tileW = 56;\n\t\tthis.tileH = 64;\t// should be multiple of at least 8, probably 16 too...\n\t\tthis.tileVO = this.tileH * 3 / 4; // It will be 3/4 of tileH (32 is one side, 64 is long radius, so 48 will be the voffset)\n\t\tthis.tsPrior = 0;\n\t\tthis.ts = 0;\n\t\tthis.winningAnimation = { started: false, start_ts: 0 };\n\t}\n\t/** @param {number} idx\n\t *  @returns {Tile} */\n\ttileFromIdx(idx) {\n\t\tlet y = ~~(idx/this.width);\t// works for 32-bit positive numbers\n\t\tlet x = idx%this.width;\n\t\treturn this.grid[y][x];\n\t}\n\t/** @param {number} idx\n\t *  @returns {[number,number]} */\n\txyFromIdx(idx) {\n\t\tlet y = ~~(idx/this.width);\n\t\tlet x = idx % this.width;\n\t\treturn [x,y];\n\t}\n\t/** @param {number} x\n\t *  @param {number} y\n\t *  @returns {number} */\n\tidxFromXy(x,y) {\n\t\treturn (y*this.width+x);\n\t}\n\t/** @param {Tile[][] | null} oldgrid\n\t *  @returns {Tile[][]} */\t\n\tnewGrid(oldgrid = null) {\n\t\tlet grid = [];\n\t\tfor(let y=0; y<this.height; y++) {\n\t\t\tlet row = [];\n\t\t\tfor(let x=0; x<this.width; x++) {\n\t\t\t\tif(oldgrid == null) row.push(new _tile_js__WEBPACK_IMPORTED_MODULE_1__.Tile());\n\t\t\t\telse row.push(new _tile_js__WEBPACK_IMPORTED_MODULE_1__.Tile(oldgrid[y][x]));\n\t\t\t}\n\t\t\tgrid.push(row);\n\t\t}\n\t\treturn grid;\n\t}\n\t/** @param {string} puzstr\n\t *  @returns {Tile[][]} */\n\tnewGridFromPuzstr(puzstr) {\n\t\tlet grid = this.newGrid();\n\t\t// load puzzle string\n\t\tlet bytes = puzstr.split('');\n\t\t// convert into a conns array e.g. [ 0, 1, 0, 1, 1, 1 ]\n\t\tfor (let y=0; y<this.height; y++) {\n\t\t\tfor (let x=0; x<this.width; x++) {\n\t\t\t\tlet conns = [ 0, 0, 0, 0, 0, 0 ];\n\t\t\t\tlet byte = bytes[y*this.width+x];\n\t\t\t\tlet idx = BASE.indexOf(byte);\n\t\t\t\tif((idx & 0x01) == 0x01) conns[0] = 1;\n\t\t\t\tif((idx & 0x02) == 0x02) conns[1] = 1;\n\t\t\t\tif((idx & 0x04) == 0x04) conns[2] = 1;\n\t\t\t\tif((idx & 0x08) == 0x08) conns[3] = 1;\n\t\t\t\tif((idx & 0x10) == 0x10) conns[4] = 1;\n\t\t\t\tif((idx & 0x20) == 0x20) conns[5] = 1;\n\t\t\t\tgrid[y][x].setup(conns);\n\t\t\t}\n\t\t}\n\t\t// TODO: Set isolated as appropriate on every tile!!! And do a run to find connected sets and make them\n\t\t// the same color!!!\n\t\treturn grid;\n\t}\n\t/** @returns {boolean} */\t\n\thaveWinCondition() {\n\t\t// does this.grid == this.solvedGrid?\n\t\tif(!Array.isArray(this.solvedGrid)) return false;\n\t\tfor(let y=0; y<this.height;y++) {\n\t\t\tfor(let x=0; x<this.width;x++) {\n\t\t\t\tif((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.arrayEqual)(this.grid[y][x].conns, this.solvedGrid[y][x].conns)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.won = true;\n\t\treturn true;\n\t}\n\t/** @param {number} ts\n\t *  @returns {boolean} */\n\tpause(ts) {\t\t// return true if we are now paused, false if we are now running\n\t\tif(!this.timer.running) {\n\t\t\tthis.timer.start(ts);\n\t\t\treturn false;\n\t\t} else {\n\t\t\tthis.timer.stop(ts);\n\t\t\treturn true;\n\t\t}\n\t}\n\t/** @param {string} s */\n\tloadLevelString(s) {\n\t\t// level string is in format w,h,puzzle,solution\n\t\tlet [ title, w, h, puz, sol ] = s.split(',');\n\t\tthis.title = title;\n\t\tthis.width = parseInt(w);\n\t\tthis.height = parseInt(h);\n\t\tthis.grid = this.newGridFromPuzstr(puz);\n\t\tthis.solvedGrid = this.newGridFromPuzstr(sol);\n\t}\n\t/** @param {number} px\n\t *  @param {number} py\n\t *  @returns {[number,number]} */\n\txyFromPixelCoords(px,py) {\n\t\t// we can perform a basic translation first\n\t\t// then we need to do an advanced check for the corners\n\t\tlet gy = Math.floor(py / this.tileVO);\n\t\tlet ypc = (py % this.tileVO) / this.tileVO; // top 1/3 is in the triangle rect\n\t\tlet xindent = 0;\n\t\tif(gy%2==1) xindent = this.tileW / 2;\n\t\tlet gx = Math.floor((px - xindent) / this.tileW);\n\t\tlet xpc = ((px - xindent) % this.tileW) / this.tileW;\n\t\t\n\t\tif (ypc < (1.0/3.0)) {\n\t\t\t// we are in the triangle rectangle, we gotta figure out if we are in the triangle or not\n\t\t\t//  +----+----+            yf=0.0\n\t\t\t//  |AA.' '.BB|\n\t\t\t//  |.'     '.|\n\t\t\t//  +----+----+            yf=1.0\n\t\t\t//xpc=0.0    xpc=1.0\n\t\t\tlet yf = ypc*3.0;\n\t\t\tif(xpc < 0.5) {\n\t\t\t\tif ((2.0*xpc)<(1.0-yf)) { // we are in the AA region\n\t\t\t\t\t// tile is same grid x, but grid y is one less\n\t\t\t\t\tif(gy%2==0) gx -= 1;\n\t\t\t\t\tgy -= 1;\n\t\t\t\t} else {\n\t\t\t\t\t//...\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(((xpc-0.5)*2.0)>yf) { // we are in the BB region\n\t\t\t\t\t// tile is one more grid x, one less grid y\n\t\t\t\t\tif(gy%2==0) gx -= 1;\n\t\t\t\t\tgy -= 1;\n\t\t\t\t\tgx += 1;\n\t\t\t\t} else {\n\t\t\t\t\t//...\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [gx,gy]; // Warning: results may be out of range\n\t}\n\t/** @param {number} x\n\t *  @param {number} y\n\t *  @returns {boolean} */\t\n\tinBounds(x,y) {\n\t\treturn (x>=0 && x<this.width && y>= 0 && y<this.height);\n\t}\n\t/** @param {number} a\n\t *  @returns {number} */\t\n\tinvertAngle(a) {\n\t\tif(a > 2) { return a-3; }\n\t\treturn a+3;\n\t}\n\t/** @param {number} x\n\t *  @param {number} y\n\t *  @param {number} a\n\t *  @returns {[number,number] | null} */\n\txyAtAngle(x,y,a) {\n\t\t// return the [x,y] of a tile at the angle a\n\t\t// or return null if there is no tile\n\n\t\tlet nx = x;\n\t\tlet ny = y;\n\t\t\n\t\tif(a==0) nx++;\n\t\telse if(a==1) {\n\t\t\tif(y%2==0) ny++;\n\t\t\telse { nx++; ny++; }\n\t\t}\n\t\telse if(a==2) {\n\t\t\tif(y%2==0) { nx--; ny++; }\n\t\t\telse { ny++; }\n\t\t}\n\t\telse if(a==3) { nx--; }\n\t\telse if(a==4) {\n\t\t\tif(y%2==0) { nx--; ny--; }\n\t\t\telse ny--;\n\t\t}\n\t\telse if(a==5) {\n\t\t\tif(y%2==0) ny--;\n\t\t\telse { nx++; ny--; }\n\t\t}\n\t\tif(nx<0 || nx>(this.width-1) || ny<0 || ny>(this.height-1)) return null;\n\t\treturn [nx,ny];\n\t}\n\t/** @param {number} x\n\t *  @param {number} y\n\t *  @returns {boolean} */\t\n\tisIsolated(x,y) {\n\t\t// return TRUE if this tile is not connected to any others\n\t\t// check each angle from this tile\n\t\tfor(let a=0; a<6; a++) {\n\t\t\tif(!this.grid[y][x].conns[a]) continue;\t// if we're not connected, continue\n\t\t\tlet nxy = this.xyAtAngle(x,y,a);\t// get tile that's at that angle\n\t\t\tif(nxy == null) continue; // no tile there\n\t\t\tlet [nx,ny] = nxy;\n\t\t\tif(this.grid[ny][nx].conns[this.invertAngle(a)]) {\n\t\t\t\treturn false;\t// we have a connection!\n\t\t\t}\n\t\t}\n\t\treturn true; \t// not connected\n\t}\n\t/** @param {number} x\n\t *  @param {number} y\n\t *  @returns {number[][]} */\n\tgetSurroundingTiles(x,y) {\n\t\t// return an array of surrounding tiles (i.e. not the ones on the edge)\n\t\t// array of items [x,y]\n\t\tlet arr = [];\n\t\tfor(let a=0; a<6; a++) {\n\t\t\tlet nxy = this.xyAtAngle(x,y,a);\t// get tile that's at that angle\n\t\t\tif(nxy == null) continue; // no tile there\n\t\t\tlet [nx,ny] = nxy;\n\t\t\tarr.push([nx,ny]);\n\t\t}\n\t\treturn arr;\n\t}\n\t/** @param {number} px\n\t *  @param {number} py\n\t *  @param {boolean} recursive\n\t *  @returns {[Set<number>, Set<number>]} */\t\n\tgetConnectedTiles(px,py,recursive) {\t\t// depth first, easier to find loops\n\t\tclass StackItem {\n\t\t/** @param {number} px\n\t\t *  @param {number} py\n\t\t *  @param {number | null} fromangle\n\t\t *  @param {number} angle */\t\t\t\t\n\t\t\tconstructor(px,py,fromangle,angle) {\n\t\t\t\tthis.x = px;\n\t\t\t\tthis.y = py;\n\t\t\t\tthis.fromangle = fromangle;\n\t\t\t\tthis.angle = angle;\n\t\t\t}\n\t\t}\n\t\t// return a set of [x,y] of tiles that are connected to this one\n\t\tlet stack = [new StackItem(px,py,null,0)];\n\t\tlet tileSet = new Set();\n\t\ttileSet.add(py*this.width+px);\n\t\tlet loopedSet = new Set();\n\t\t\n\t\twhile(stack.length > 0) {\n\t\t\tlet item = stack.pop();\n\t\t\tlet x = item.x;\n\t\t\tlet y = item.y;\n\t\t\tlet fromangle = item.fromangle;\n\t\t\tlet angle = item.angle;\n\t\t\t\n\t\t\tif(angle>5)\tcontinue;\n\n\t\t\t// add ourselves back on to the stack, with the next angle\n\t\t\tstack.push(new StackItem(x,y,fromangle,angle+1));\n\t\t\tif(fromangle != null && fromangle == angle) continue; // don't check where we came from\n\t\t\tif(!this.grid[y][x].conns[angle]) continue;\t// if we're not connected, continue\n\t\t\tlet nxy = this.xyAtAngle(x,y,angle);\t// get tile that's at that angle\n\t\t\tif(nxy == null) continue; // no tile there\n\t\t\tlet [nx,ny] = nxy;\n\t\t\tif(this.grid[ny][nx].conns[this.invertAngle(angle)]) {\n\t\t\t\t// we have a connection!\n\t\t\t\t// check if it's already stored\n\t\t\t\tif(tileSet.has(ny*this.width+nx)) {\n\t\t\t\t\t// the stack should have all the looped tiles in it, between \n\t\t\t\t\t// where the stack has nx,ny, and the end of stack.\n\n\t\t\t\t\t// find the start point\n\t\t\t\t\tlet idx=0;\n\t\t\t\t\tfor(idx=0; idx<stack.length; idx++) {\n\t\t\t\t\t\tif(stack[idx].x == nx && stack[idx].y == ny) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(idx==stack.length) {\n\t\t\t\t\t\t// console.log(\"unable to find looped tile in stack\",nx,ny);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// copy the whole looped section to loopedSet\n\t\t\t\t\t\tfor(let i=idx; i<stack.length; i++) {\n\t\t\t\t\t\t\tloopedSet.add(stack[i].y*this.width+stack[i].x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttileSet.add(ny*this.width+nx);\n\t\t\t\t\tif(recursive) {\n\t\t\t\t\t\tstack.push(new StackItem(nx,ny,this.invertAngle(angle),0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [tileSet,loopedSet];\n\t}\n}\n\n\n\n//# sourceURL=webpack://pipehex/./src/game.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-manager.js */ \"./src/game-manager.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ \"./src/storage.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n/* index.js\n * Entry point. Initialise event handlers, initialise gameManager.\n * Copyright 2022 David Atkinson <david47k@d47.co>\n */\n\n\n\n\n\ndocument.getElementById(\"restart_button\").addEventListener('click', function() {\n    _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.restart({restartSolved:true});\n});\n\ndocument.getElementById('prev_puzzle').addEventListener('click', function() {\n    _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.prevPuzzle();\n});\n\n\nlet nps = document.getElementsByClassName('next_puzzle');\nfor(let i=0; i<nps.length; i++) {\n    nps.item(i).addEventListener('click', function() {\n        _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.nextPuzzle();\n    });\n};\n\n\ndocument.getElementById(\"pause\").addEventListener('click', function(ev) {\n    const paused = _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.game.pause(_game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.game.tsPrior);\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setAriaPressed)(ev.target, paused);\n});\n\ndocument.getElementById('show_fps').addEventListener('click', function(ev) {\n    _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showFPS = !_game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showFPS;\n    const active = _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showFPS;\n    let element = document.getElementById('menu_fps');\n    let target = document.getElementById('show_fps');\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setAriaPressed)(target, active);\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setHideClass)(element, active);\n    _storage_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].saveStr('showFPS',active.toString());});\n\ndocument.getElementById('show_timer').addEventListener('click', function(ev) {\n    _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showTimer = !_game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showTimer;\n    const active = _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showTimer;\n    let element = document.getElementById('menu_time');\n    let target = document.getElementById('show_timer');\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setAriaPressed)(target, active);\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setHideClass)(element, active);\n    _storage_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].saveStr('showTimer',active.toString());\n});\n\ndocument.getElementById(\"settings_button\").addEventListener('click', function (ev) {\n    _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showSettings = !_game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showSettings;\n    const active = _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showSettings;\n    let element = document.getElementById('settings_menu');\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setAriaPressed)(ev.target, active);\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setHideClass)(element, active);\n});\n\ndocument.getElementById(\"stats_button\").addEventListener('click', function (ev) {\n    _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showStats = !_game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showStats;\n    const active = _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.showStats;\n    let element = document.getElementById('stats');\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setAriaPressed)(ev.target, active);\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.setHideClass)(element, active);\n});\n\nlet sgs = document.getElementById(\"settings_game_size\");\nArray.prototype.forEach.call(sgs.children, (el) => {\n    el.addEventListener('click', \n        /** @param {Event} ev */\n        function (ev) {\n        const s = Number.parseInt(el.getAttribute('data'));\n        _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.setSize(s);\n    });\n});\n\n\n;(function () {\n    /** @param {number} ts */\n    function main(ts) {\n        //gameManager.stopMain = window.requestAnimationFrame(main);\n        window.requestAnimationFrame(main);\n        _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.gameManager.render(ts);\n    }\n    main(0);\n})();\n\n\n//# sourceURL=webpack://pipehex/./src/index.js?");

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* Copyright 2022 David Atkinson */\r\n\r\nconst prefix = 'phex_';\r\n\r\n/** @param {string} key\r\n *  @param {any} val\r\n *  @returns {any} */\r\nfunction replacerMap(key, val) {\r\n\tif(val instanceof Map) {\r\n\t\treturn { dataType: 'Map', val: Array.from(val.entries()) };\r\n\t}\r\n    return val;\r\n}\r\n\r\n/** @param {string} key\r\n *  @param {any} val \r\n *  @returns {any} */\r\nfunction reviverMap(key, val) {\r\n\tif(typeof val === 'object' && val !== null && val.dataType === 'Map') {\r\n\t\treturn new Map(val.val);\r\n    }\r\n\treturn val;\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n\t/** @param {string} key\r\n\t *  @param {any} val */\r\n\tsave: function(key,val) {\r\n\t\tlocalStorage.setItem('phex_'+key, val);\r\n\t},\r\n\t/** @param {string} key\r\n\t *  @param {number} val */\r\n\tsaveInt: function(key,val) { this.save(key,val); },\r\n\t/** @param {string} key\r\n\t *  @param {string} val */\r\n\tsaveStr: function(key,val) { this.save(key,val); },\r\n\t/** @param {string} key\r\n\t *  @param {Map<any,any>} val */\r\n\tsaveMap: function(key,val) {\t\t\r\n\t\tlocalStorage.setItem('phex_'+key, JSON.stringify(val, replacerMap));\r\n\t},\r\n\t/** @param {string} key\r\n\t *  @param {Map<any,any>} def */\r\n\tloadMap: function(key,def) {\r\n\t\tvar o = localStorage.getItem('phex_'+key);\r\n\t\tif(o == null) return def;\r\n\t\treturn JSON.parse(o, reviverMap);\r\n\t},\r\n\t/** @param {string} key\r\n\t *  @param {number | null} def */\r\n\tloadInt: function(key,def) {\r\n\t\tvar x = parseInt(localStorage.getItem('phex_'+key));\r\n\t\tif(isNaN(x)) return def;\r\n\t\treturn x;\r\n\t},\r\n\t/** @param {string} key\r\n\t *  @param {string | null} def */\r\n\tloadStr: function(key,def) {\r\n\t\tlet r = localStorage.getItem('phex_'+key);\r\n\t\tif(r == null) return def;\r\n\t\treturn r;\r\n\t},\r\n\t/** @param {string} key\r\n\t *  @param {any} val */\r\n\tsaveObj: function(key,val) {\r\n\t\tlocalStorage.setItem('phex_'+key, JSON.stringify(val));\r\n\t},\r\n\t/** @param {string} key\r\n\t *  @param {any} def */\r\n\tloadObj: function(key,def) {\r\n\t\tvar o = localStorage.getItem('phex_'+key);\r\n\t\tif(o == null) return def;\r\n\t\treturn JSON.parse(o);\r\n\t},\r\n});\r\n\n\n//# sourceURL=webpack://pipehex/./src/storage.js?");

/***/ }),

/***/ "./src/tile.js":
/*!*********************!*\
  !*** ./src/tile.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tile\": () => (/* binding */ Tile)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view.js */ \"./src/view.js\");\n/* tile.js\n * A hexagonal tile, including rotation, determining angles, shapes etc.\n * Copyright 2022 David Atkinson <david47k@d47.co>\n */\n\n\n/* Angles:\n *  4 /\\ 5      4 NW    NE 5 \n *   /  \\\n * 3|    |0     3 W      E 0   \n *  |    |\n *   \\  /       2 SW    SE 1  \n *  2 \\/ 1\n * \n */\n\n\n\n\n/* These are unused:\nconst angles = [ \"E\", \"SE\", \"SW\", \"W\", \"NW\", \"NE\" ];\nconst shapes = [ \"ZERO\", \"ONE\", \"TWO_NARROW\", \"TWO_WIDE\", \"TWO_STRAIGHT\", \"THREE_E\", \"THREE_Y_LEFT\",\n\t\"THREE_Y_RIGHT\", \"THREE_Y_WIDE\", \"FOUR_K\", \"FOUR_PLANE\", \"FOUR_X\", \"FIVE\", \"SIX\" ];\n*/\n\nfunction coinFlip() { // return 0 or 1\n\treturn Math.trunc(Math.random() * 2);\n}\n\nconst shapeMatchArr = [\n\t[ 0, 0, 0, 0, 0, 0 ], // zero\n\t[ 1, 0, 0, 0, 0, 0 ], // one\n    [ 1, 1, 0, 0, 0, 0 ], // two_narrow\n    [ 1, 0, 1, 0, 0, 0 ], // two_wide \n    [ 1, 0, 0, 1, 0, 0 ], // two_straight \n    [ 1, 1, 1, 0, 0, 0 ], // three_e     \n    [ 1, 0, 1, 1, 0, 0 ], // three_y_left\n    [ 1, 0, 0, 1, 1, 0 ], // three_y_right\n    [ 1, 0, 1, 0, 1, 0 ], // three_y_wide\n    [ 1, 1, 1, 1, 0, 0 ], // four_k      \n    [ 1, 0, 1, 1, 1, 0 ], // four_plane  \n    [ 1, 1, 0, 1, 1, 0 ], // four_x      \n    [ 1, 1, 1, 1, 1, 0 ], // five         \n    [ 1, 1, 1, 1, 1, 1 ], // six         \n];\n\n/** @param {number[]} connsA\n *  @param {number[]} connsB \n *  @returns {{m:boolean, a:number}}\n */\nfunction shapeMatch(connsA, connsB) { // type ibool[6], ibool[6]\n\tvar rconns = connsB;\n\tfor (var i=0; i<6; i++) {\n\t\tif((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.arrayEqual)(rconns, connsA)) {\n\t\t\treturn { m: true, a:i };\n\t\t}\n\t\trconns = [ rconns[5], rconns[0], rconns[1], rconns[2], rconns[3], rconns[4] ];\n\t}\n\t\t\n\treturn { m: false, a:0 };\n}\n\t\n/** @param {number[]} conns\n *  @returns {{s:number,a:number}}\n */\nfunction connsToShapeAngle(conns) {\t\t// conns type: bool[6]\n\tlet pipeCount = 0;\n\tlet angleIdx = 0;\n\tlet angleFound = 0;\n\tfor (let i = 0; i < 6; i++) {\n\t\tif(conns[i] == 1) {\n\t\t\tpipeCount++;\n\t\t\tif(!angleFound) {\n\t\t\t\tangleIdx = i; // find angle for pipeCount = 1\n\t\t\t\tangleFound = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlet shapeIdx = 0;\n\t// if pipeCount == 0 then shapeIdx = 0, angleIdx is set to 0\n\tif(pipeCount==1) {\n\t\tshapeIdx = 1; // angle determined above\n\t} else if (pipeCount>=2 && pipeCount <=5) {\n\t\tfor(let testIdx = 2; testIdx <= 12; testIdx++) {\t\t\n\t\t\tconst matchResult = shapeMatch(conns, shapeMatchArr[testIdx]);\n\t\t\tif(matchResult.m==true) { \n\t\t\t\tshapeIdx = testIdx;\n\t\t\t\tangleIdx = matchResult.a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (pipeCount==6) {\n\t\tshapeIdx = 13;\n\t\t// angleIdx is set to 0\n\t}\n\n\treturn { s: shapeIdx, a: angleIdx };\n}\n\nclass Tile {\n\tconstructor( { conns = [coinFlip(), coinFlip(), coinFlip(), coinFlip(), coinFlip(), coinFlip()],\n\t\t\t\t\tcolor = _view_js__WEBPACK_IMPORTED_MODULE_1__.PALETTE_ANNEX, isolated = true, locked = false, looped = false } = {} ) {\n\t\tthis.conns = conns;\n\t\tlet shapeAngle = connsToShapeAngle(this.conns);\n\t\tthis.shape = shapeAngle.s;\n\t\tthis.angle = shapeAngle.a;\n\t\tthis.color = color; \t// color type: colorsIndex\n\t\tthis.isolated = isolated;\t// are we connected to any other tiles?\n\t\tthis.locked = locked;\t//\n\t\tthis.looped = looped;\t//\n\t}\n\trotate(ccw = false) {\n\t\tif(!ccw) { // not counter-clockwise\n\t\t\tthis.conns = [ this.conns[5], this.conns[0], this.conns[1], this.conns[2], this.conns[3], this.conns[4] ];\n\t\t\tthis.angle++;\n\t\t\tif(this.angle==6) this.angle=0;\n\t\t\tif( (this.shape==4  && this.angle==3) ||\n\t\t\t\t(this.shape==8  && this.angle==2) ||\n\t\t\t\t(this.shape==11 && this.angle==3) ||\n\t\t\t\tthis.shape==13 ) {\n\t\t\t\t\tthis.angle=0;\n\t\t\t}\n\t\t} else { // counter-clockwise\n\t\t\tthis.conns = [ this.conns[1], this.conns[2], this.conns[3], this.conns[4], this.conns[5], this.conns[0] ];\n\t\t\tthis.angle--;\n\t\t\tif(this.angle==-1) {\n\t\t\t\tif(this.shape==4) this.angle=2;\n\t\t\t\telse if(this.shape==8) this.angle=1;\n\t\t\t\telse if(this.shape==11) this.angle=2;\n\t\t\t\telse if(this.shape==13) this.angle=0;\n\t\t\t\telse this.angle=5;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t/** @param {number[]} nconns */\n\tsetup(nconns) {\n\t\tthis.conns = nconns;\n\t\tconst shapeAngle = connsToShapeAngle(this.conns);\n\t\tthis.shape = shapeAngle.s;\n\t\tthis.angle = shapeAngle.a;\n\t}\n\t/** @param {Tile} tile */\n\tequal(tile) {\n\t\tthis.conns.every((x,i) => x == tile.conns[i]);\n\t}\n}\n\n\n//# sourceURL=webpack://pipehex/./src/tile.js?");

/***/ }),

/***/ "./src/timer.js":
/*!**********************!*\
  !*** ./src/timer.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Timer\": () => (/* binding */ Timer),\n/* harmony export */   \"timestringFrom\": () => (/* binding */ timestringFrom)\n/* harmony export */ });\n/* timer.js\n * A simple timer, with string converstion function.\n * Copyright 2022 David Atkinson <david47k@d47.co>\n */\n\n/** @param {number} ms */\nfunction timestringFrom(ms) {\n\tlet s = Math.trunc(ms / 1000);\n\tconst m = Math.trunc(s / 60);\n\ts -= (m * 60);\n\tlet ss = s.toString();\n\tif(ss.length < 2) ss = '0' + ss;\n\treturn m.toString() + ':' + ss;\n}\n\n\nclass Timer {\n\tconstructor({time = 0} = {}) {\n\t\tthis.time = time;\n\t\tthis.timestamp = 0;\n\t\tthis.running = false;\n\t}\n\t/** @param {number} ts */\n\tstart(ts) {\n\t\tif(this.running) {\n\t\t\tthis.update(ts);\n\t\t} else {\n\t\t\tthis.timestamp = ts;\n\t\t\tthis.running = true;\n\t\t}\n\t}\n\t/** @param {number} ts */\n\tstop(ts) {\n\t\tif(this.running) {\n\t\t\tthis.update(ts);\n\t\t\tthis.running = false;\n\t\t}\n\t}\n\treset() {\n\t\tthis.running = false;\n\t\tthis.time = 0;\n\t}\n\t/** @param {number} ts */\n\tupdate(ts) {\n\t\tif(this.running) {\n\t\t\tconst delta = ts - this.timestamp;\n\t\t\tif(delta >= 0) {\n\t\t\t\tthis.time += delta;\n\t\t\t} else {\n\t\t\t\tconsole.log('time has gone backwards');\n\t\t\t}\n\t\t\tthis.timestamp = ts;\n\t\t}\n\t}\t\t\n\tgetMillis() {\n\t\treturn this.time;\n\t}\n\ttimestring() {\n\t\treturn timestringFrom(this.time);\n\t}\t\n}\n\n\n\n//# sourceURL=webpack://pipehex/./src/timer.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arrayEqual\": () => (/* binding */ arrayEqual),\n/* harmony export */   \"setAriaPressed\": () => (/* binding */ setAriaPressed),\n/* harmony export */   \"setHideClass\": () => (/* binding */ setHideClass)\n/* harmony export */ });\n/* util.js\n * Misc utility functions.\n * Copyright 2022 David Atkinson <david47k@d47.co>\n */\n\n/** @param {any} a\n *  @param {any} b \n *  @returns {boolean}\n */\nfunction arrayEqual(a, b) {\n    if(Array.isArray(a) && Array.isArray(b)) {\n\t\treturn a.length === b.length && a.every((v, i) => arrayEqual(v,b[i]));\n\t} else {\n\t\treturn a === b;\n\t}\n}\n\n/** @param {EventTarget} target\n *  @param {boolean} active */\nfunction setAriaPressed(target, active) {\n    if(target instanceof HTMLButtonElement) {\n        target.setAttribute('aria-pressed', active.toString());\n    }\n}    \n\n/** @param {Element} element\n *  @param {boolean} active */\nfunction setHideClass(element, active) {\n    if(active) {\n        element.classList.remove('hide');\n    } else {\n        element.classList.add('hide');\n    }    \n}    \n\n\n//# sourceURL=webpack://pipehex/./src/util.js?");

/***/ }),

/***/ "./src/view.js":
/*!*********************!*\
  !*** ./src/view.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PALETTE\": () => (/* binding */ PALETTE),\n/* harmony export */   \"PALETTE_ANNEX\": () => (/* binding */ PALETTE_ANNEX),\n/* harmony export */   \"PALETTE_B\": () => (/* binding */ PALETTE_B),\n/* harmony export */   \"View\": () => (/* binding */ View)\n/* harmony export */ });\n/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tile.js */ \"./src/tile.js\");\n/* harmony import */ var _game_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game-manager.js */ \"./src/game-manager.js\");\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game.js */ \"./src/game.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage.js */ \"./src/storage.js\");\n/* view.js\n * The view of the game, rendered to the HTML document / DOM.\n * Copyright 2022 David Atkinson <david47k@d47.co>\n */\n\n\n\n\n\n\n\n/*\n * for future use\n * \nlet tile_sizes = [ [ 56, 64, 48 ], [ 42, 48, 36 ], [ 28, 32, 24 ] ];\n*/\n\n// Original palette, 12 colours, purple is a bit dark\nconst PALETTE_ORIGINAL = [ '#f51a3c','#a92393','#623297','#0060b3','#0078c5','#02b2b5',\n\t'#24bb4e','#add73c','#ffdd00','#ffc110','#fc9b1e','#f97625',];\n\n// Modified original palette that brightens up the dark colours and seperates the blues\nconst PALETTE_SHARP = [ '#f51a3c','#a92393','#743bb2','#0067c2','#00a7c5','#02b597',\n\t'#24bb4e','#add73c','#ffdd00','#ffc110','#fc9b1e','#f97625',];\n\n// Munsell C8V7 palette, 20 colours\nconst PALETTE_MC8V7 = [ \n'#d99a94', '#da9d80', '#d4a46e', '#cbab5d', '#bfb351', '#b5b94e', '#a6bf5a', '#92c477', '#83c596', '#7ec4a5', \n'#79c3b6', '#77c0c8', '#7dbbd8', '#89b4e1', '#9aade4', '#aea4e2', '#bc9fd8', '#ca9ac8', '#cf98bf', '#d798a4'\n];\n\n\nconst PALETTE = PALETTE_MC8V7;\nconst PALETTE_ANNEX = 20;\nconst PALETTE_B = [ '#a7a7a7', '#555555', '#333333', '#000000' ];\n\nconst drawMethods = ['img','canvas_ctx2d','manual_mask'];\n\n\nclass View {\n\t/** @param {number} gameWidth\n\t *  @param {number} gameHeight */\n\tconstructor(gameWidth, gameHeight) {\n\t\tthis.gameWidth = gameWidth;\n\t\tthis.gameHeight = gameHeight;\n\t\tthis.container = document.getElementById('container');\n\t\t//this.scoreboard = document.getElementById('scoreboard');\n\t\tthis.drawMethod = 1;\n\t\tthis.alwaysRenderAll = 0;\n\t\tthis.canvasCache = new Map();\n\t\t\n/*\t\tthis.srcImage = new Image();   // Create new img element\n\t\tthis.srcImage.loading = \"eager\";\n\t\tthis.srcImage.addEventListener('load', function() {\n\t\t\tconsole.log(\"image loaded\"); \n\t\t\tgameManager.view.setUp(gameManager.game.width, gameManager.game.puzzle_h);\n\t\t}); */\n\t\t\n\t\t// the resize event will need fixing so it redraws everything\n\t\t// i.e. gm.paintAll();\n\t\t/* window.addEventListener('resize', () => {\n\t\t\tthis.setUp(gameManager.game.width, gameManager.game.puzzle_h);\n\t\t}); */\n\t\tthis.unitOnScreenH = 64;\n\t\tthis.unitOnScreenVO = 48;\n\t\tthis.unitOnScreenW = 56;\n\n\t\tthis.setUp(gameWidth, gameHeight); // this function will start the image loading process\n\t}\n\t/** @param {number} gameWidth\n\t *  @param {number} gameHeight */\n\tsetUp(gameWidth, gameHeight) {\t// gameWidth and gameHeight are in grid units\t\t\t\n\t\t// some things cannot be done until the gameManager object is fully initialised\n\t\tif(!_game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager) {\n\t\t\tsetTimeout(() => { this.setUp(gameWidth, gameHeight); }, 10);\n\t\t\treturn;\n\t\t}\n\t\tconsole.log('setting up...')\n\t\tthis.renderButtons();\n\n\t\tlet { width, height } = this.container.getBoundingClientRect();\n\t\theight = document.documentElement.clientHeight - 15; // override the above height estimate: 10px padding 2px border 3px unknown\n\n\t\t//this.unitOnScreen = Math.floor(Math.min( width / gameWidth,\theight / gameHeight ));\n\t\t//this.unitOnScreen = ( Math.floor(this.unitOnScreen / 4) * 4 );\t// canvas drawImage is crappy, reduce aliasing artifacts\n\t\t//if(this.unitOnScreen > 256) this.unitOnScreen = 256; // reducing aliasing artifacts - can also split src into individual sprites\n\t\t//console.log(\"screen unit:\", this.unitOnScreenW, \" \", this.unitOnScreenH, \" \", this.unitOnScreenVO);\n\n\t\t// Because ImageBitmap options & imageSmoothingQuality aren't yet widely supported, and OffscreenCanvas isn't widely supported,\n\t\t// we are using pre-sized images. we can scale down and it looks OK, but we can't scale up.\n\t\t// blocksizes 64, 128, 192, 256\n\t\t// we return because this method will get called again once the image is loaded\n\t\tif(this.srcBlockH != 64) {\n\t\t\tthis.srcBlockH = 64;\n\t\t\tthis.srcBlockW = 56;\n/*\t\t\tthis.srcImage.src = 'tiles_56x64.png';\n\t\t\tconsole.log('loading src image');\n\t\t\treturn; */\n\t\t}\n\n\t\t// remove the old canvas, if it exists\n\t\tconst [child] = this.container.children;\n\t\tif(child) {\n\t\t\tthis.container.removeChild(child);\n\t\t}\n\t\t\n\t\t// create a new canvas\n\t\tconst canvas = document.createElement('canvas');\n\t\tthis.container.appendChild(canvas);\n\t\tthis.context = canvas.getContext('2d');\n\t\tcanvas.setAttribute('width',''+(gameWidth * this.unitOnScreenW + Math.floor(this.unitOnScreenW/2)));\n\t\tcanvas.setAttribute('height',''+((gameHeight + 1) * this.unitOnScreenVO - (this.unitOnScreenH/2)));\n\t\t//console.log('new canvas created');\n\t\t\n\t\t// render (update stats display) with current stats\n\t\tthis.renderStats();\n\t}\n\trenderButtons() {\n\t\t// update state of showFPS button\n\t\t(0,_util_js__WEBPACK_IMPORTED_MODULE_3__.setAriaPressed)(document.getElementById('show_fps'), _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.showFPS);\n\t\t(0,_util_js__WEBPACK_IMPORTED_MODULE_3__.setHideClass)(document.getElementById('menu_fps'), _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.showFPS);\n\t\t\n\t\t// update state of showTimer button\n\t\t(0,_util_js__WEBPACK_IMPORTED_MODULE_3__.setAriaPressed)(document.getElementById('show_timer'), _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.showTimer);\n\t\t(0,_util_js__WEBPACK_IMPORTED_MODULE_3__.setHideClass)(document.getElementById('menu_time'), _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.showTimer);\n\t}\t\n\t/** @param {number} dx\n\t *  @param {number} dy\n\t *  @param {number} sx\n\t *  @param {number} sy */\n\trenderImg(dx, dy, sx, sy) {\n/*\t\tsx = sx * this.srcBlockW;\n\t\tsy = sy * this.srcBlockH;\n\t\tif(dy%2==1) dx += 0.5;\n\t\t\n//\t\tif(this.srcImage.complete && this.context) { \n\t\tif(this.context) {\n\t\t\tthis.context.drawImage(this.srcImage,\n\t\t\t\tsx,sy,\n\t\t\t\tthis.srcBlockW,this.srcBlockH,\n\t\t\t\tMath.floor(this.unitOnScreenW * dx),\n\t\t\t\tthis.unitOnScreenVO * dy,\n\t\t\t\tthis.unitOnScreenW,this.unitOnScreenH);\n\t\t} */\n\t}\n\t/** @param {HTMLCanvasElement} srcCanvas\n\t *  @param {number} dx\n\t *  @param {number} dy */\n\trenderFromCanvas(srcCanvas, dx, dy) {\n\t\tif(dy%2==1) dx += 0.5;\n\t\tif(this.context) {\n\t\t\tthis.context.drawImage(srcCanvas, 0, 0, this.unitOnScreenW, this.unitOnScreenH,\n\t\t\t\tMath.floor(this.unitOnScreenW * dx),\n\t\t\t\tthis.unitOnScreenVO * dy,\n\t\t\t\tthis.unitOnScreenW,this.unitOnScreenH);\n\t\t}\n\t}\n\t/** @returns {HTMLCanvasElement} */\n\tgetHexCanvas(colorIdx = PALETTE_ANNEX+2) {\n\t\tconst key = colorIdx+65536;\t// allowing 16 bits for line tile cache\n\t\tif(this.canvasCache.has(key)) {\n\t\t\treturn this.canvasCache.get(key);\n\t\t}\n\t\t\n\t\tlet canvas = document.createElement('canvas');\n\t\tlet ctx = canvas.getContext('2d');\t\t\n\t\tlet width = this.unitOnScreenW;\n\t\tlet height = this.unitOnScreenH;\n\t\tcanvas.setAttribute('width',width.toString());\n\t\tcanvas.setAttribute('height',height.toString());\n\t\t//this.unitOnScreenH = 64;\n\t\t//this.unitOnScreenVO = 48;\n\t\t//this.unitOnScreenW = 56;\n\t\tctx.clearRect(0,0,width,height);\n\t\tif(colorIdx >= PALETTE_ANNEX) ctx.fillStyle = PALETTE_B[colorIdx - PALETTE_ANNEX];\n\t\telse ctx.fillStyle = PALETTE[colorIdx];\n\t\tctx.strokeStyle = PALETTE_B[3];\n\t\tctx.lineWidth = 1;\n\t\tctx.beginPath();\n\t\tctx.moveTo(width/2, 0);\n\t\tctx.lineTo(width, height/4);\n\t\tctx.lineTo(width, height*3/4);\n\t\tctx.lineTo(width/2, height);\n\t\tctx.lineTo(0, height*3/4);\n\t\tctx.lineTo(0, height/4);\n\t\tctx.lineTo(width/2, 0);\n\t\tctx.fill();\n\t\tctx.stroke();\n\n\t\t// cache the result\n\t\tthis.canvasCache.set(key,canvas);\n\t\treturn canvas;\n\t}\n\t/** @param {number[]} conns\n\t *  @param {number} colorIdx\n\t *  @returns {HTMLCanvasElement} */\n\tgetLineCanvas(conns, colorIdx) {\n\t\t// Use 2d context line drawing functions.\n\n\t\t// check if it is in cache\n\t\t// create key\n\t\tlet key = 0;\n\t\tfor(let i=0;i<6;i++) {\n\t\t\tif(conns[i]) key |= 1 << i;\n\t\t}\n\t\tkey |= colorIdx << 6;\n\t\tif(this.canvasCache.has(key)) {\n\t\t\treturn this.canvasCache.get(key);\n\t\t}\n\n\t\tlet canvas = document.createElement('canvas');\n\t\tlet ctx = canvas.getContext('2d');\n\t\tlet width = this.unitOnScreenW;\n\t\tlet height = this.unitOnScreenH;\n\t\tcanvas.setAttribute('width',width.toString());\n\t\tcanvas.setAttribute('height',height.toString());\n\t\tctx.lineCap = 'butt';\n\t\tctx.lineJoin = 'bevel';\n\t\tctx.clearRect(0,0,width,height);\n\t\tif (colorIdx >= PALETTE_ANNEX) {\n\t\t\tctx.fillStyle = PALETTE_B[colorIdx - PALETTE_ANNEX];\n\t\t\tctx.strokeStyle = PALETTE_B[colorIdx - PALETTE_ANNEX];\n\t\t} else {\n\t\t\tctx.fillStyle = PALETTE[colorIdx];\n\t\t\tctx.strokeStyle = PALETTE[colorIdx];\n\t\t}\n\t\tctx.lineWidth = height / 8;\n\t\t// For each angle:\n\t\tlet count = 0;\n\t\tfor(let i=0; i<conns.length; i++) {\n\t\t\tif(!conns[i]) continue;\n\t\t\tcount++;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(width/2,height/2);\n\t\t\tlet dx = width/2;\n\t\t\tlet dy = height/2;\n\t\t\tif(i==0) dx = width;\n\t\t\telse if(i==1) { dy = height * 7 / 8; dx = width * 3 / 4; }\n\t\t\telse if(i==2) { dy = height * 7 / 8; dx = width * 1 / 4; }\n\t\t\telse if(i==3) dx = 0;\n\t\t\telse if(i==4) { dy = height * 1 / 8; dx = width * 1 / 4; }\n\t\t\telse if(i==5) { dy = height * 1 / 8; dx = width * 3 / 4; }\n\t\t\tctx.lineTo(dx,dy);\n\t\t\tctx.stroke();\n\t\t}\n\t\t// If it's a single, draw a larger hub circle\n\t\tlet r = height/16;\n\t\tif(count==1) r = height/8;\n\t\tctx.beginPath();\n\t\tctx.moveTo(width/2,height/2);\n\t\tctx.arc(width/2,height/2,r,0,2*Math.PI,true);\n\t\tctx.fill(); // automatically closes the path\n\n\t\t// cache the result\n\t\tthis.canvasCache.set(key,canvas);\n\n\t\treturn canvas;\n\t}\n\trenderStats() {\n\t\tif(_game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager && _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.stats) {\n\t\t\tconst stats = _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.stats;\n\t\t\tdocument.getElementById('stats_size').innerHTML = stats.puztype;\n\t\t\tdocument.getElementById('stats_num').innerHTML = stats.num;\n\t\t\tdocument.getElementById('stats_best').innerHTML = stats.best;\n\t\t\tdocument.getElementById('stats_best3').innerHTML = stats.best3;\n\t\t\tdocument.getElementById('stats_best5').innerHTML = stats.best5;\n\t\t\tdocument.getElementById('stats_best10').innerHTML = stats.best10;\n\t\t}\n\t}\n\trender() {\n\t\tlet gm = _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager;\n\t\tif(!gm) {\n\t\t\tconsole.log('view::render() called with no gamemanager initialised');\n\t\t\treturn;\n\t\t}\n\t\tif(!this.context) {\n\t\t\t//console.log('view::render() called with no context initialised');\n\t\t\treturn;\n\t\t}\n\t\tlet game = _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.game;\n\t\tlet ts = _game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.game.ts;\n\t\t\n\t\tif(this.alwaysRenderAll || gm.game.winningAnimation.started) {\n\t\t\tgm.paintAll(); // will update gm.renderSet appropriately\n\t\t}\n\t\t\t\t\n\t\tfor (const idx of gm.renderSet) {\n\t\t\tconst [x,y] = gm.game.xyFromIdx(idx);\n\t\t\tif(this.drawMethod == 0) {\t// old draw method for using an image as a source\n\t\t\t\tthis.renderImg(x,y,0,0);\t\t// background hexagon\n\t\t\t\tthis.renderImg(x,y,game.grid[y][x].angle,game.grid[y][x].shape);\t// line shape\n\t\t\t} else if(this.drawMethod == 1) {\n\t\t\t\tlet hexCanvas = null;\n\t\t\t\tif(gm.game.winningAnimation.started) {\n\t\t\t\t\tlet palidx = Math.floor((ts - gm.game.winningAnimation.start_ts)/100) + x;\n\t\t\t\t\tpalidx = Math.floor(palidx)%(PALETTE.length);\n\t\t\t\t\thexCanvas = this.getHexCanvas(palidx);\n\t\t\t\t} else if(gm.loopedSet.has(idx)) {\n\t\t\t\t\thexCanvas = this.getHexCanvas(PALETTE_ANNEX+1);\n\t\t\t\t} else {\n\t\t\t\t\thexCanvas = this.getHexCanvas(PALETTE_ANNEX+2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.renderFromCanvas(hexCanvas, x, y);\n\t\t\t\tlet colorIdx = gm.game.grid[y][x].color;\n\t\t\t\tlet srcCanvas = this.getLineCanvas(game.grid[y][x].conns,colorIdx);\n\t\t\t\tthis.renderFromCanvas(srcCanvas, x, y);\n\t\t\t} else {\n\t\t\t\t// unimplemented draw method\n\t\t\t}\n\t\t};\n\t\t\n\t\t// clear the render set, now we've rendered all the tiles\n\t\tgm.renderSet.clear();\n\t\t\n\t\t// update fps\n\t\tif(_game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.showFPS) {\n\t\t\tlet fps = Math.floor(1000.0 / (ts - game.tsPrior));\n\t\t\tdocument.getElementById(\"fps_text\").innerHTML = '' + fps;\n\t\t}\n\t\t\n\t\t// update cached timestamp\n\t\tgame.tsPrior = ts;\n\n\t\t// update puzzle title\n\t\tdocument.getElementById(\"puzzle_title\").innerHTML = game.title;\n\t\t\n\t\t// update timer\n\t\tdocument.getElementById(\"timer_text\").innerHTML = game.timer.timestring();\n\n\t\t// update win screen\n\t\tif(game.won) {\n\t\t\tdocument.getElementById('wintime').innerHTML = game.wintime;\n\t\t\tdocument.getElementById('winner').classList.remove('hide');\n\t\t\tthis.renderStats();\t// update statistics\n\t\t} else {\n\t\t\tdocument.getElementById(\"winner\").classList.add(\"hide\");\n\t\t}\n\t\t\n\t\t// update paused button\n\t\tconst paused = !_game_manager_js__WEBPACK_IMPORTED_MODULE_1__.gameManager.game.timer.running;\n\t\tdocument.getElementById('pause').setAttribute('aria-pressed', paused.toString());\n\t}\n}\n\n\n//# sourceURL=webpack://pipehex/./src/view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;