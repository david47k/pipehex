/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./config.js":
/*!*******************!*\
  !*** ./config.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* Copyright 2022 David Atkinson */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n\tFPS: 30,\n});\n\n\n//# sourceURL=webpack://pipehex/./config.js?");

/***/ }),

/***/ "./game-manager.js":
/*!*************************!*\
  !*** ./game-manager.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => (/* binding */ Game),\n/* harmony export */   \"GameManager\": () => (/* binding */ GameManager),\n/* harmony export */   \"Tile\": () => (/* binding */ Tile),\n/* harmony export */   \"Timer\": () => (/* binding */ Timer),\n/* harmony export */   \"timestring_from_ms\": () => (/* binding */ timestring_from_ms)\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"./config.js\");\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view.js */ \"./view.js\");\n/* harmony import */ var _puzzles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./puzzles.js */ \"./puzzles.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage.js */ \"./storage.js\");\n/* Copyright 2022 David Atkinson */\n\n\n\n\n\n\n\n/*\n *    /\\        4 NW    NE 5 \n *   /  \\\n *  |    |      3 W      E 0   \n *  |    |\n *   \\  /       2 SW    SE 1  \n *    \\/\n * \n * */\n\n\nconst angles = [ \"E\", \"SE\", \"SW\", \"W\", \"NW\", \"NE\" ];\nconst shapes = [ \"ZERO\", \"ONE\", \"TWO_NARROW\", \"TWO_WIDE\", \"TWO_STRAIGHT\", \"THREE_E\", \"THREE_Y_LEFT\",\n\t\"THREE_Y_RIGHT\", \"THREE_Y_WIDE\", \"FOUR_K\", \"FOUR_PLANE\", \"FOUR_X\", \"FIVE\", \"SIX\" ];\n\n// shape & rotation maps to connections\nconst example_conns = [ 0, 0, 0, 1, 1, 1 ];\t// type: ibool[6]\n\nconst shape_match_arr = [\n\t[ 0, 0, 0, 0, 0, 0 ], // zero\n\t[ 1, 0, 0, 0, 0, 0 ], // one\n    [ 1, 1, 0, 0, 0, 0 ], // two_narrow\n    [ 1, 0, 1, 0, 0, 0 ], // two_wide \n    [ 1, 0, 0, 1, 0, 0 ], // two_straight \n    [ 1, 1, 1, 0, 0, 0 ], // three_e     \n    [ 1, 0, 1, 1, 0, 0 ], // three_y_left\n    [ 1, 0, 0, 1, 1, 0 ], // three_y_right\n    [ 1, 0, 1, 0, 1, 0 ], // three_y_wide\n    [ 1, 1, 1, 1, 0, 0 ], // four_k      \n    [ 1, 0, 1, 1, 1, 0 ], // four_plane  \n    [ 1, 1, 0, 1, 1, 0 ], // four_x      \n    [ 1, 1, 1, 1, 1, 0 ], // five         \n    [ 1, 1, 1, 1, 1, 1 ], // six         \n];\n\nfunction array_equal(a, b) {\n    if(Array.isArray(a) && Array.isArray(b)) {\n\t\treturn a.length === b.length && a.every((v, i) => array_equal(v,b[i]));\n\t} else {\n\t\treturn a === b;\n\t}\n}\n\nfunction shape_match(conns_a, conns_b) { // type ibool[6], ibool[6]\n\tvar rconns = conns_b;\n\tfor (var i=0; i<6; i++) {\n\t\tif(array_equal(rconns, conns_a)) {\n\t\t\treturn [ true, i ];\n\t\t}\n\t\trconns = [ rconns[5], rconns[0], rconns[1], rconns[2], rconns[3], rconns[4] ];\n\t}\n\t\t\n\treturn [ false, 0 ];\n}\n\t\nfunction conns_to_shapeangle(conns) {\t\t// conns type: bool[6]\n\tlet pipe_count = 0;\n\tlet angle_idx = 0;\n\tlet angle_found = 0;\n\tfor (let i = 0; i < 6; i++) {\n\t\tif(conns[i] == 1) {\n\t\t\tpipe_count++;\n\t\t\tif(!angle_found) {\n\t\t\t\tangle_idx = i; // find angle for pipe_count = 1\n\t\t\t\tangle_found = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlet shape_idx = 0;\n\t// if pipe_count == 0 then shape_idx = 0, angle_idx is set to 0\n\tif(pipe_count==1) {\n\t\tshape_idx = 1; // angle determined above\n\t} else if (pipe_count>=2 && pipe_count <=5) {\n\t\tfor(let test_idx = 2; test_idx <= 12; test_idx++) {\t\t\n\t\t\tlet [r,a] = shape_match(conns, shape_match_arr[test_idx]);\n\t\t\tif(r==true) { \n\t\t\t\tshape_idx = test_idx;\n\t\t\t\tangle_idx = a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (pipe_count==6) {\n\t\tshape_idx = 13;\n\t\t// angle_idx is set to 0\n\t}\n\n\treturn [ shape_idx, angle_idx ];\n}\n\n\nclass Timer {\n\tconstructor({time = 0} = {}) {\n\t\tthis.time = time;\n\t\tthis.timestamp = null;\n\t\tthis.running = false;\n\t}\n\tstart(ts) {\n\t\tif(this.running) {\n\t\t\tthis.update(ts);\n\t\t} else {\n\t\t\tthis.timestamp = ts;\n\t\t\tthis.running = true;\n\t\t}\n\t}\n\tstop(ts) {\n\t\tif(this.running) {\n\t\t\tthis.time += ts - this.timestamp;\n\t\t\tthis.running = false;\n\t\t}\n\t}\n\treset() {\n\t\tthis.running = false;\n\t\tthis.time = 0;\n\t}\n\tset_millis(ms) {\n\t\tthis.time = ms;\n\t}\n\tupdate(ts) {\n\t\tif(this.running) {\n\t\t\tthis.time += ts - this.timestamp;\n\t\t\tthis.timestamp = ts;\n\t\t}\n\t}\t\t\n\tget_millis() {\n\t\treturn this.time;\n\t}\n\tget_timestring(ts) {\n\t\tlet t = this.time;\n\t\tif(this.running) {\n\t\t\tt += ts - this.timestamp;\n\t\t}\n\t\tlet s = Math.trunc(t / 1000);\n\t\tlet m = Math.trunc(s / 60);\n\t\ts -= (m * 60);\n\t\tlet ss = s.toString();\n\t\tif(ss.length < 2) ss = '0' + ss;\n\t\treturn m.toString() + ':' + ss;\n\t}\t\n}\n\nfunction timestring_from_ms(ms) {\n\tlet s = Math.trunc(ms / 1000);\n\tlet m = Math.trunc(s / 60);\n\ts -= (m * 60);\n\tlet ss = s.toString();\n\tif(ss.length < 2) ss = '0' + ss;\n\treturn m.toString() + ':' + ss;\t\n}\n\nclass Tile {\n\tconstructor( { conns = [coin_flip(), coin_flip(), coin_flip(), coin_flip(), coin_flip(), coin_flip()],\n\t\t\t\t\tcolor = 0, isolated = true, locked = false, looped = false } = {} ) {\n\t\tthis.conns = conns;\n\t\t[ this.shape, this.angle ] = conns_to_shapeangle(this.conns);\n\t\tthis.color = color; \t// color type: colors_index\n\t\tthis.isolated = isolated;\t// are we connected to any other tiles?\n\t\tthis.locked = locked;\t//\n\t\tthis.looped = looped;\t//\n\t}\n\trotate_cw() {\n\t\tthis.conns = [ this.conns[5], this.conns[0], this.conns[1], this.conns[2], this.conns[3], this.conns[4] ];\n\t\tthis.angle++;\n\t\tif(this.angle==6) this.angle=0;\n\t\tif( (this.shape==4  && this.angle==3) ||\n\t\t\t(this.shape==8  && this.angle==2) ||\n\t\t\t(this.shape==11 && this.angle==3) ||\n\t\t\tthis.shape==13 ) {\n\t\t\t\tthis.angle=0;\n\t\t}\n\t}\n\trotate_ccw() {\n\t\tthis.conns = [ this.conns[1], this.conns[2], this.conns[3], this.conns[4], this.conns[5], this.conns[0] ];\n\t\tthis.angle--;\n\t\tif(this.angle==-1) {\n\t\t\tif(this.shape==4) this.angle=2;\n\t\t\telse if(this.shape==8) this.angle=1;\n\t\t\telse if(this.shape==11) this.angle=2;\n\t\t\telse if(this.shape==13) this.angle=0;\n\t\t\telse this.angle=5;\n\t\t}\n\t}\n\tsetup(nconns) {\n\t\tthis.conns = nconns;\n\t\t[ this.shape, this.angle ] = conns_to_shapeangle(this.conns);\n\t}\n\tequal(tile) {\n\t\tthis.conns.every((x,i) => x == tile.conns[i]);\n\t}\n}\n\nfunction coin_flip() { // return 0 or 1\n\treturn Math.trunc(Math.random() * 2);\n}\n\nfunction rand_inclusive(n) {\n\treturn Math.trunc(Math.random() * (n+1));\n}\n\nlet tile_sizes = [ [ 56, 64, 48 ], [ 42, 48, 36 ], [ 28, 32, 24 ] ];\nconst BASE = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_-';\n\nclass Game {\n\tconstructor({ puzzle_w=0, puzzle_h=0, grid = null, sol_grid = null, won = false, title = '(puzzle title)', timer = {time:0} } = {}) {\n\t\tthis.puzzle_w = puzzle_w;\n\t\tthis.puzzle_h = puzzle_h;\n\t\tthis.grid = this.new_game_grid(grid);\n\t\tthis.sol_grid = sol_grid;\n\t\tthis.won = won;\n\t\tthis.title = title;\n\t\tthis.timer = new Timer(timer);\n\t\tthis.tile_w = 56;\n\t\tthis.tile_h = 64;\t// should be multiple of at least 8, probably 16 too...\n\t\tthis.tile_vo = this.tile_h * 3 / 4; // It will be 3/4 of tile_h (32 is one side, 64 is long radius, so 48 will be the voffset)\n\t\tthis.last_ts = 0;\n\t\tthis.ts = 0;\n\t\tthis.winningAnimation = { started: false, start_ts: 0 };\n\t}\n\ttile_from_xy(x,y) {\n\t\treturn this.grid[y][x];\n\t}\n\ttile_from_idx(idx) {\n\t\tlet y = ~~(idx/this.puzzle_w);\t// works for 32-bit positive numbers\n\t\tlet x = idx%this.puzzle_w;\n\t\treturn this.grid[y][x];\n\t}\n\txy_from_idx(idx) {\n\t\tlet y = ~~(idx/this.puzzle_w);\n\t\tlet x = idx % this.puzzle_w;\n\t\treturn [x,y];\n\t}\n\tidx_from_xy(x,y) {\n\t\treturn (y*this.puzzle_w+x);\n\t}\n\tnew_game_grid(oldgrid = null) {\n\t\tlet grid = [];\n\t\tfor(let y=0; y<this.puzzle_h; y++) {\n\t\t\tlet row = [];\n\t\t\tfor(let x=0; x<this.puzzle_w; x++) {\n\t\t\t\tif(oldgrid == null) row.push(new Tile());\n\t\t\t\telse row.push(new Tile(oldgrid[y][x]));\n\t\t\t}\n\t\t\tgrid.push(row);\n\t\t}\n\t\treturn grid;\n\t}\n\tnew_game_grid_from_puzstr(puzstr) {\n\t\tlet grid = this.new_game_grid();\n\t\t// load puzzle string\n\t\tlet bytes = puzstr.split('');\n\t\t// convert into a conns array e.g. [ 0, 1, 0, 1, 1, 1 ]\n\t\tfor (let y=0; y<this.puzzle_h; y++) {\n\t\t\tfor (let x=0; x<this.puzzle_w; x++) {\n\t\t\t\tlet conns = [ 0, 0, 0, 0, 0, 0 ];\n\t\t\t\tlet byte = bytes[y*this.puzzle_w+x];\n\t\t\t\tlet idx = BASE.indexOf(byte);\n\t\t\t\tif((idx & 0x01) == 0x01) conns[0] = 1;\n\t\t\t\tif((idx & 0x02) == 0x02) conns[1] = 1;\n\t\t\t\tif((idx & 0x04) == 0x04) conns[2] = 1;\n\t\t\t\tif((idx & 0x08) == 0x08) conns[3] = 1;\n\t\t\t\tif((idx & 0x10) == 0x10) conns[4] = 1;\n\t\t\t\tif((idx & 0x20) == 0x20) conns[5] = 1;\n\t\t\t\tgrid[y][x].setup(conns);\n\t\t\t}\n\t\t}\n\t\t// TODO: Set isolated as appropriate on every tile!!! And do a run to find connected sets and make them\n\t\t// the same color!!!\n\t\treturn grid;\n\t}\n\thave_win_condition() {\n\t\t// does this.grid == this.sol_grid?\n\t\tif(!Array.isArray(this.sol_grid)) return false;\n\t\tfor(let y=0; y<this.puzzle_h;y++) {\n\t\t\tfor(let x=0; x<this.puzzle_w;x++) {\n\t\t\t\tif(array_equal(this.grid[y][x].conns, this.sol_grid[y][x].conns)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.won = true;\n\t\treturn true;\n\t}\n\tpause(ts) {\t\t// return true if we are now paused, false if we are now running\n\t\tif(!this.timer.running) {\n\t\t\tthis.timer.start(ts);\n\t\t\treturn false;\n\t\t} else {\n\t\t\tthis.timer.stop(ts);\n\t\t\treturn true;\n\t\t}\n\t}\n\tload_level_string(s) {\n\t\t// level string is in format w,h,puzzle,solution\n\t\tlet [ title, w, h, puz, sol ] = s.split(',');\n\t\tthis.title = title;\n\t\tthis.puzzle_w = parseInt(w);\n\t\tthis.puzzle_h = parseInt(h);\n\t\tthis.grid = this.new_game_grid_from_puzstr(puz);\n\t\tthis.sol_grid = this.new_game_grid_from_puzstr(sol);\n\t}\n\tpixel_xy_to_grid_xy(px,py) {\n\t\t// we can perform a basic translation first\n\t\t// then we need to do an advanced check for the corners\n\t\tlet gy = Math.floor(py / this.tile_vo);\n\t\tlet ypc = (py % this.tile_vo) / this.tile_vo; // top 1/3 is in the triangle rect\n\t\tlet xindent = 0;\n\t\tif(gy%2==1) xindent = this.tile_w / 2;\n\t\tlet gx = Math.floor((px - xindent) / this.tile_w);\n\t\tlet xpc = ((px - xindent) % this.tile_w) / this.tile_w;\n\t\t\n\t\tif (ypc < (1.0/3.0)) {\n\t\t\t// we are in the triangle rectangle, we gotta figure out if we are in the triangle or not\n\t\t\t//  +----+----+            yf=0.0\n\t\t\t//  |AA.' '.BB|\n\t\t\t//  |.'     '.|\n\t\t\t//  +----+----+            yf=1.0\n\t\t\t//xpc=0.0    xpc=1.0\n\t\t\tlet yf = ypc*3.0;\n\t\t\tif(xpc < 0.5) {\n\t\t\t\tif ((2.0*xpc)<(1.0-yf)) { // we are in the AA region\n\t\t\t\t\t// tile is same grid x, but grid y is one less\n\t\t\t\t\tif(gy%2==0) gx -= 1;\n\t\t\t\t\tgy -= 1;\n\t\t\t\t} else {\n\t\t\t\t\t//...\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(((xpc-0.5)*2.0)>yf) { // we are in the BB region\n\t\t\t\t\t// tile is one more grid x, one less grid y\n\t\t\t\t\tif(gy%2==0) gx -= 1;\n\t\t\t\t\tgy -= 1;\n\t\t\t\t\tgx += 1;\n\t\t\t\t} else {\n\t\t\t\t\t//...\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [gx,gy]; // Warning: results may be out of range\n\t}\n\tinBounds(x,y) {\n\t\treturn (x>=0 && x<this.puzzle_w && y>= 0 && y<this.puzzle_h);\n\t}\n\tinvertAngle(a) {\n\t\tif(a > 2) { return a-3; }\n\t\treturn a+3;\n\t}\n\tget_gxy_at_angle(x,y,a) {\n\t\t// return the [x,y] of a tile at the angle a\n\t\t// or return null if there is no tile\n\n\t\tlet nx = x;\n\t\tlet ny = y;\n\t\t\n\t\tif(a==0) nx++;\n\t\telse if(a==1) {\n\t\t\tif(y%2==0) ny++;\n\t\t\telse { nx++; ny++; }\n\t\t}\n\t\telse if(a==2) {\n\t\t\tif(y%2==0) { nx--; ny++; }\n\t\t\telse { ny++; }\n\t\t}\n\t\telse if(a==3) { nx--; }\n\t\telse if(a==4) {\n\t\t\tif(y%2==0) { nx--; ny--; }\n\t\t\telse ny--;\n\t\t}\n\t\telse if(a==5) {\n\t\t\tif(y%2==0) ny--;\n\t\t\telse { nx++; ny--; }\n\t\t}\n\t\tif(nx<0 || nx>(this.puzzle_w-1) || ny<0 || ny>(this.puzzle_h-1)) return null;\n\t\treturn [nx,ny];\n\t}\n\tis_isolated(x,y) {\n\t\t// return TRUE if this tile is not connected to any others\n\t\t// check each angle from this tile\n\t\tfor(let a=0; a<6; a++) {\n\t\t\tif(!this.grid[y][x].conns[a]) continue;\t// if we're not connected, continue\n\t\t\tlet nxy = this.get_gxy_at_angle(x,y,a);\t// get tile that's at that angle\n\t\t\tif(nxy == null) continue; // no tile there\n\t\t\tlet [nx,ny] = nxy;\n\t\t\tif(this.grid[ny][nx].conns[this.invertAngle(a)]) {\n\t\t\t\treturn false;\t// we have a connection!\n\t\t\t}\n\t\t}\n\t\treturn true; \t// not connected\n\t}\n\tget_surrounding_tiles(x,y) {\n\t\t// return an array of surrounding tiles (i.e. not the ones on the edge)\n\t\t// array of items [x,y]\n\t\tlet arr = [];\n\t\tfor(let a=0; a<6; a++) {\n\t\t\tlet nxy = this.get_gxy_at_angle(x,y,a);\t// get tile that's at that angle\n\t\t\tif(nxy == null) continue; // no tile there\n\t\t\tlet [nx,ny] = nxy;\n\t\t\tarr.push([nx,ny]);\n\t\t}\n\t\treturn arr;\n\t}\n\tget_connected_tiles_o(x,y,tileset,recursive) {\n\t\t// return a set of [x,y] of tiles that are connected to this one\n\t\t// return an empty set for none\n\t\t// initially pass a set with just this [x,y]\n\t\tfor(let a=0; a<6; a++) {\n\t\t\tif(!this.grid[y][x].conns[a]) continue;\t// if we're not connected, continue\n\t\t\tlet nxy = this.get_gxy_at_angle(x,y,a);\t// get tile that's at that angle\n\t\t\tif(nxy == null) continue; // no tile there\n\t\t\tlet [nx,ny] = nxy;\n\t\t\tif(this.grid[ny][nx].conns[this.invertAngle(a)]) {\n\t\t\t\t// we have a connection!\n\t\t\t\t// check we don't already have it stored\n\t\t\t\tif(!tileset.has(ny*this.puzzle_w+nx)) {\n\t\t\t\t\ttileset.add(ny*this.puzzle_w+nx);\n\t\t\t\t\tif(recursive) tileset = this.get_connected_tiles_o(nx,ny,tileset,recursive);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tileset;\n\t}\n\tget_connected_tiles_breadth_first(px,py,recursive) {\n\t\t// return a set of [x,y] of tiles that are connected to this one\n\t\tlet stack = [[px,py,null]];\n\t\tlet tileset = new Set();\n\t\ttileset.add(py*this.puzzle_w+px);\n\t\tlet looped_set = new Set();\n\t\t\n\t\tfor(let i=0; i<stack.length; i++) {\n\t\t\tlet x = stack[i][0];\n\t\t\tlet y = stack[i][1];\n\t\t\tlet fromangle = stack[i][2];\n\t\t\tfor(let a=0; a<6; a++) {\n\t\t\t\tif(fromangle != null && fromangle == a) continue; // don't check where we came from\n\t\t\t\tif(!this.grid[y][x].conns[a]) continue;\t// if we're not connected, continue\n\t\t\t\tlet nxy = this.get_gxy_at_angle(x,y,a);\t// get tile that's at that angle\n\t\t\t\tif(nxy == null) continue; // no tile there\n\t\t\t\tlet [nx,ny] = nxy;\n\t\t\t\tif(this.grid[ny][nx].conns[this.invertAngle(a)]) {\n\t\t\t\t\t// we have a connection!\n\t\t\t\t\t// check we don't already have it stored\n\t\t\t\t\tif(tileset.has(ny*this.puzzle_w+nx)) {\n\t\t\t\t\t\tconsole.log('FOUND A LOOP',nx,ny);\t\n\t\t\t\t\t\t// TO DO: return a pruned version of the whole tileset\n\t\t\t\t\t\tlooped_set.add(y*this.puzzle_w+x);\n\t\t\t\t\t\tlooped_set.add(ny*this.puzzle_w+nx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttileset.add(ny*this.puzzle_w+nx);\n\t\t\t\t\t\tif(recursive) {\n\t\t\t\t\t\t\tstack.push([nx,ny,this.invertAngle(a)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [tileset,looped_set];\n\t}\n\tget_connected_tiles(px,py,recursive) {\t\t// depth first, easier to find loops\n\t\t// return a set of [x,y] of tiles that are connected to this one\n\t\tlet stack = [[px,py,null,0]];\n\t\tlet tileset = new Set();\n\t\ttileset.add(py*this.puzzle_w+px);\n\t\tlet looped_set = new Set();\n\t\t\n\t\twhile(stack.length > 0) {\n\t\t\tlet popped = stack.pop();\n\t\t\tlet x = popped[0];\n\t\t\tlet y = popped[1];\n\t\t\tlet fromangle = popped[2];\n\t\t\tlet angle = popped[3];\n\t\t\t\n\t\t\tif(angle>5)\tcontinue;\n\n\t\t\t// add ourselves back on to the stack, with the next angle\n\t\t\tstack.push([x,y,fromangle,angle+1]);\n\t\t\tif(fromangle != null && fromangle == angle) continue; // don't check where we came from\n\t\t\tif(!this.grid[y][x].conns[angle]) continue;\t// if we're not connected, continue\n\t\t\tlet nxy = this.get_gxy_at_angle(x,y,angle);\t// get tile that's at that angle\n\t\t\tif(nxy == null) continue; // no tile there\n\t\t\tlet [nx,ny] = nxy;\n\t\t\tif(this.grid[ny][nx].conns[this.invertAngle(angle)]) {\n\t\t\t\t// we have a connection!\n\t\t\t\t// check if it's already stored\n\t\t\t\tif(tileset.has(ny*this.puzzle_w+nx)) {\n\t\t\t\t\t// the stack should have all the looped tiles in it, between \n\t\t\t\t\t// where the stack has nx,ny, and the end of stack.\n\n\t\t\t\t\t// find the start point\n\t\t\t\t\tlet idx=0;\n\t\t\t\t\tfor(idx=0; idx<stack.length; idx++) {\n\t\t\t\t\t\tif(stack[idx][0] == nx && stack[idx][1] == ny) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(idx==stack.length) {\n\t\t\t\t\t\t// console.log(\"unable to find looped tile in stack\",nx,ny);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// copy the whole looped section to looped_set\n\t\t\t\t\t\tfor(let i=idx; i<stack.length; i++) {\n\t\t\t\t\t\t\tlooped_set.add(stack[i][1]*this.puzzle_w+stack[i][0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttileset.add(ny*this.puzzle_w+nx);\n\t\t\t\t\tif(recursive) {\n\t\t\t\t\t\tstack.push([nx,ny,this.invertAngle(angle),0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [tileset,looped_set];\n\t}\n}\n\n\nfunction readFile(filename, onloadfn) {\n    const oReq = new XMLHttpRequest();\n    oReq.open(\"GET\", filename, true);\n    oReq.responseType = \"text\";\n    oReq.onload = function(oEvent) {\n\t\tconst t = oReq.response;\n\t\tconsole.log(\"puzzle file loaded: \",filename);\n\t\t// parse CSV into lines\n\t\tlet puzzle_array = [];\n\t\tlet lines = t.split(\"\\n\");\n\t\tlines.forEach( l => { if(l.length>8) puzzle_array.push(l); } );\t\t\n        onloadfn(puzzle_array);\n    };\n    oReq.send(null);\n}\n\n\nclass GameManager {\n\tconstructor() {\n\t\tthis.PUZZLES = { '5': [], '10': [], '15': [], '20': [], '30': [], '40': [] };\n\t\tthis.puzzle_type = _storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadStr('puzzle_type','5');\n\t\tthis.puzzle_idx = _storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadInt('puzzle_idx'+this.puzzle_type,0);\n\t\tthis.showStats = false;\n\t\tthis.showFPS = false;\n\t\tthis.showTimer = true;\n\t\t\n\t\treadFile('/puzzles5.csv', a => this.PUZZLES['5'] = a );\n\t\treadFile('/puzzles10.csv', a => this.PUZZLES['10'] = a );\n\t\treadFile('/puzzles15.csv', a => this.PUZZLES['15'] = a );\n\t\treadFile('/puzzles20.csv', a => this.PUZZLES['20'] = a );\n\t\treadFile('/puzzles30.csv', a => this.PUZZLES['30'] = a );\n\t\treadFile('/puzzles40.csv', a => this.PUZZLES['40'] = a );\n\n\t\tthis.transitionList = [];\n\t\tthis.renderSet = new Set();\n\t\tthis.loopedSet = new Set();\n\t\tthis.game = this.loadGame(parseInt(this.puzzle_type));\n\t\tthis.updateStats();\n\t\t\n\t\tthis.view = new _view_js__WEBPACK_IMPORTED_MODULE_1__.View(this.game.puzzle_w,this.game.puzzle_h);\n\n\t\tthis.restart({restart_solved:false, restart_game:false});\n\n\t\tthis.view.container.addEventListener('contextmenu', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\treturn false;\n\t\t});\n\t\tthis.view.container.addEventListener('click', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t\tev.stopImmediatePropagation();\n\t\t\treturn false;\n\t\t});\n\t\tthis.view.container.addEventListener('mouseup', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t\tev.stopImmediatePropagation();\n\t\t\treturn false;\n\t\t});\t\t\t\n\t\tthis.view.container.addEventListener('mousedown', function(ev) {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t\tev.stopImmediatePropagation();\n\t\t\tvar gm = document.gameManager;\n\t\t\tvar [x, y] = gm.game.pixel_xy_to_grid_xy(ev.offsetX, ev.offsetY);\n\t\t\tif(gm.game.inBounds(x,y)) {\n\t\t\t\tgm.click(x,y,ev.buttons);\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n\tprev_puzzle() {\n\t\tif(this.puzzle_idx <= 0) {\n\t\t\tconsole.log(\"No previous puzzles!\");\n\t\t} else {\n\t\t\tthis.puzzle_idx--;\n\t\t\t_storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].saveInt('puzzle_idx'+this.puzzle_type,this.puzzle_idx);\n\t\t\tthis.restart();\n\t\t}\n\t}\n\tnext_puzzle() {\n\t\tif(this.puzzle_idx + 1 >= this.PUZZLES[this.puzzle_type].length) {\n\t\t\tconsole.log(\"Ran out of puzzles!\");\n\t\t} else {\n\t\t\tthis.puzzle_idx++;\n\t\t\t_storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].saveInt('puzzle_idx'+this.puzzle_type,this.puzzle_idx);\n\t\t\tthis.restart();\n\t\t}\n\t}\n\trestart({restart_solved = false, restart_game = true}={}) {\t\n\t\t// check if we have finished loading the puzzle data, if not, try again later.\n\t\tif(this.PUZZLES[this.puzzle_type].length < 1) {\n\t\t\tsetTimeout(() => document.gameManager.restart({restart_solved:restart_solved, restart_game:restart_game}), 100);\n\t\t\treturn;\n\t\t}\n\n\t\t// use puzzle_type and puzzle_idx\n\t\tif(restart_game || this.game.puzzle_w==0) {\n\t\t\tlet n = parseInt(this.puzzle_type);\n\t\t\tthis.game = new Game({puzzle_w:n,puzzle_h:n});\n\t\t\tthis.game.load_level_string(this.PUZZLES[this.puzzle_type][this.puzzle_idx]);\n\t\t}\n\t\t\n\t\t// if the game has been solved, actually load the solved puzzle, and set win condition\n\t\tif(!restart_solved) {\n\t\t\tlet hs = _storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadObj('highscore_'+this.puzzle_type, []);\n\t\t\tlet t = parseInt(hs[this.puzzle_idx]);\n\t\t\tif(Number.isInteger(t)) {\n\t\t\t\tthis.game.grid = this.game.sol_grid;\n\t\t\t\tthis.game.timer.set_millis(t);\n\t\t\t\tif(this.game.have_win_condition()) {\n\t\t\t\t\tthis.on_win();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set up the view, and set all tiles to be rendered\n\t\tif(this.view) {\n\t\t\tthis.view.setUp(this.game.puzzle_w,this.game.puzzle_h);\n\t\t\tthis.paintAll();\n\t\t}\n\t}\n\t\n\tsetSize(n) {\n\t\tthis.puzzle_type = n.toString();\n\t\t_storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].saveStr('puzzle_type',this.puzzle_type);\n\t\tthis.puzzle_idx = _storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadInt('puzzle_idx'+this.puzzle_type,0);\n\t\tthis.updateStats();\n\t\tthis.restart();\n\t}\n\tupdateLoopSet() {\n\t\tconst prevSet = this.loopedSet;\n\t\tthis.loopedSet = new Set();\n\t\t// we can use get_connected_tiles and read the looped set\t\t\n\t\t// TO DO: have a more efficient mode, where we only look at tiles surounding the clicked tile\n\n\t\tlet tiles = [];\n\t\tfor(let n=0;n<(this.game.puzzle_h*this.game.puzzle_w);n++) {\n\t\t\ttiles.push(n);\n\t\t}\n\t\t\n\t\twhile(tiles.length > 0) {\n\t\t\tlet idx = tiles.pop();\n\t\t\tif(idx==-1) continue;\n\t\t\tlet [tx, ty] = this.game.xy_from_idx(idx);\n\t\t\tlet [tileset, looped_set] = this.game.get_connected_tiles(tx,ty,true);\n\t\t\tfor (const ti of tileset) {\n\t\t\t\tlet midx = tiles.findIndex( el => el === ti );\n\t\t\t\tif(midx != -1) {\n\t\t\t\t\ttiles[midx] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(const lt of looped_set) {\n\t\t\t\t//console.log('lt',lt);\n\t\t\t\tthis.loopedSet.add(lt);\n\t\t\t}\n\t\t}\n\t\t// we need to render everything that has changed between prevSet and loopedSet\n\t\t// ie. anything exclusive to one set, but not anything that is in both\n\t\tfor(const psi of prevSet) {\n\t\t\tif(!this.loopedSet.has(psi)) {\n\t\t\t\tthis.renderSet.add(psi);\n\t\t\t}\n\t\t}\n\t\tfor(const lsi of this.loopedSet) {\n\t\t\tif(!prevSet.has(lsi)) {\n\t\t\t\tthis.renderSet.add(lsi);\n\t\t\t}\n\t\t}\n\t}\n\trender(ts) {\n\t\tthis.game.ts = ts;\n\t\tthis.game.timer.update(ts);\n\t\t\n\t\t// check for a change\n\t\tif(this.renderSet.size > 0) {\n\t\t\t// locate loops, in the whole puzzle\n\t\t\tthis.updateLoopSet();\n\t\t}\n\t\t\n\t\tthis.view.render();\n\t}\n\tpaintAll() {\n\t\t// note: paintAll does not call render(), render will be called by the animationFrame main() loop\n\t\tthis.renderSet = new Set();\n\t\tfor(let i=0;i<(this.game.puzzle_h*this.game.puzzle_w);i++) {\n\t\t\tthis.renderSet.add(i);\n\t\t}\n\t}\n\n\tzz_runOnTimer() {\n\t\tsetInterval(this.render, 1000/_config_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].FPS);\n\t\tthis.render();\n\t}\n\tsaveGame() {\n\t\t_storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].saveObj('savegame',this.game);\n\t}\n\tloadGame(n) {\n\t\t// will return a fully loaded game, or just a dummy game\n\t\tlet loaded = _storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadObj('savegame',{puzzle_w:0,puzzle_h:0});\n\t\treturn new Game(loaded);\n\t}\n\tupdateStats() {\n\t\tlet hs = _storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadObj('highscore_'+this.puzzle_type, []);\n\t\ths.sort((a, b) => a - b);\n\t\tlet puztype = this.puzzle_type + 'x' + this.puzzle_type;\n\t\tlet best = 'tbd';\n\t\tlet best3 = 'tbd';\n\t\tlet best5 = 'tbd';\n\t\tlet best10 = 'tbd'\n\t\tif(hs.length>=1)  best = timestring_from_ms(hs[0]);\n\t\tif(hs.length>=3)  best3 = timestring_from_ms(hs.slice(0,3).reduce( (p, c) => p + c, 0 )/3.0);\n\t\tif(hs.length>=5)  best5 = timestring_from_ms(hs.slice(0,5).reduce( (p, c) => p + c, 0 )/5.0);\n\t\tif(hs.length>=10) best10 = timestring_from_ms(hs.slice(0,10).reduce( (p, c) => p + c, 0 )/10.0);\n\t\tthis.stats = { puztype: puztype, num: hs.length.toString(), best: best, best3: best3, best5: best5, best10: best10 };\n\t}\n\ton_win() {\n\t\tthis.game.timer.stop(this.game.last_ts);\n\t\tthis.game.wintime = this.game.timer.get_timestring();\n\t\tdocument.getElementById('wintime').innerHTML = this.game.wintime;\n\t\tlet hs = _storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadObj('highscore_'+this.puzzle_type, []);\n\t\ths[this.puzzle_idx] = Math.trunc(this.game.timer.get_millis());\n\t\t_storage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].saveObj('highscore_'+this.puzzle_type,hs);\n\t\tthis.updateStats();\n\t\tif(this.game.winningAnimation.started == false) {\n\t\t\t\tthis.game.winningAnimation.started = true;\n\t\t\t\tthis.game.winningAnimation.start_ts = this.game.ts;\n\t\t}\n\t}\n\tclick(x,y,buttons) {\n\t\tif(!this.game.won) {\n\t\t\tif(buttons==0 || buttons==1) this.game.grid[y][x].rotate_cw();\n\t\t\telse if(buttons==2) this.game.grid[y][x].rotate_ccw();\n\t\t\tthis.renderSet.add(this.game.idx_from_xy(x,y));\n\t\t\tthis.game.timer.start(this.game.last_ts);\n\t\t\t// check if we need to change colours of surrounding tiles\n\t\t\tlet surrounding_tiles = this.game.get_surrounding_tiles(x,y);\n\t\t\twhile(surrounding_tiles.length > 0) {\n\t\t\t\tlet [nx,ny] = surrounding_tiles.pop();\n\t\t\t\tif(this.game.is_isolated(nx,ny)) {\n\t\t\t\t\tif(this.game.grid[ny][nx].isolated == false) {\n\t\t\t\t\t\tthis.game.grid[ny][nx].isolated = true;\n\t\t\t\t\t\tthis.game.grid[ny][nx].color = 0;\n\t\t\t\t\t\tthis.renderSet.add(this.game.idx_from_xy(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(this.game.grid[ny][nx].isolated == true) {\n\t\t\t\t\t\tthis.renderSet.add(this.game.idx_from_xy(nx,ny));\n\t\t\t\t\t\tthis.game.grid[ny][nx].isolated = false;\n\t\t\t\t\t\t// it'll get a color below, now it is no longer isolated\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check if we are connected to any tiles, in which case we need to change colors\n\t\t\tlet [tileset,looped_set] = this.game.get_connected_tiles(x,y,true);\n\t\t\tlet colorIdx = this.game.grid[y][x].color;\n\t\t\tif(tileset.size <= 1) {\n\t\t\t\tthis.game.grid[y][x].isolated = true;\n\t\t\t\tcolorIdx = 0;\n\t\t\t} else {\n\t\t\t\tthis.game.grid[y][x].isolated = false;\n\t\t\t\t\n\t\t\t\tlet iter = tileset.values();\n\t\t\t\titer.next();\n\t\t\t\tlet cxy = iter.next().value;\t\t// change the color to the SECOND item in the set\n\t\t\t\tcolorIdx = this.game.tile_from_idx(cxy).color;\n\t\t\t\tif(colorIdx==0) {\n\t\t\t\t\tcolorIdx = 1+((y*this.game.puzzle_w+x)%(_view_js__WEBPACK_IMPORTED_MODULE_1__.PALETTE_SIZE-1));\t// randomish color\n\t\t\t\t\t// TODO: should ideally pick a colour that is dissimilar to surrounding colours\n\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log('tileset size:',tileset.size);\n\t\t\ttileset.forEach((val) => {\n\t\t\t\tlet tsy = Math.trunc(val/this.game.puzzle_w);\n\t\t\t\tlet tsx = val%this.game.puzzle_w;\n\t\t\t\tif(this.game.grid[tsy][tsx].color != colorIdx) {\n\t\t\t\t\tthis.game.grid[tsy][tsx].color = colorIdx;\n\t\t\t\t\tthis.renderSet.add(val);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(this.game.have_win_condition()) {\n\t\t\t\tthis.on_win();\n\t\t\t}\n\t\t}\t\t\n\t\tthis.render(this.game.ts); // render straight away without waiting for animationFrame\n\t\tthis.saveGame();\t\t\n\t}\n}\n\n\n//# sourceURL=webpack://pipehex/./game-manager.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-manager.js */ \"./game-manager.js\");\n/* Copyright 2022 David Atkinson */\n\n\n\ndocument.gameManager = new _game_manager_js__WEBPACK_IMPORTED_MODULE_0__.GameManager();\n\ndocument.getElementById(\"restart_button\").addEventListener('click', function() {\n    document.gameManager.restart({restart_solved:true});\n});\n\ndocument.getElementById('prev_puzzle').addEventListener('click', function() {\n    document.gameManager.prev_puzzle();\n});\n\nlet nps = document.getElementsByClassName('next_puzzle');\nfor(let i=0; i<nps.length; i++) {\n    nps.item(i).addEventListener('click', function() {\n        document.gameManager.next_puzzle();\n    });\n};\n\ndocument.getElementById(\"pause\").addEventListener('click', function(ev) {\n    const paused = document.gameManager.game.pause(document.gameManager.game.last_ts);\n    ev.target.setAttribute('aria-pressed', paused);\n});\n\ndocument.getElementById('show_fps').addEventListener('click', function(ev) {\n    const show = !document.gameManager.showFPS;\n    let fpsElement = document.getElementById('menu_fps');\n    document.gameManager.showFPS = show;\n    ev.target.setAttribute('aria-pressed', show);\n    if(show) {\n        fpsElement.classList.remove('hide');\n    } else {\n        fpsElement.classList.add('hide');\n    }    \n});\n\ndocument.getElementById('show_timer').addEventListener('click', function(ev) {\n    const show = !document.gameManager.showTimer;\n    const timerElement = document.getElementById('menu_time');\n    document.gameManager.showTimer = show;\n    ev.target.setAttribute('aria-pressed', show);\n    if(show) {\n        timerElement.classList.remove('hide');\n    } else {\n        timerElement.classList.add('hide');\n    }    \n    \n});\n\ndocument.getElementById(\"settings_button\").addEventListener('click', function (ev) {\n    const pressed = ev.target.getAttribute('aria-pressed') === 'true';\n    ev.target.setAttribute('aria-pressed', !pressed);\n    let settings_menu = document.getElementById(\"settings_menu\");\n    if(settings_menu.classList.contains(\"hide\")) {\n        settings_menu.classList.remove(\"hide\");\n    } else {\n        settings_menu.classList.add(\"hide\");\n    }    \n});\n\ndocument.getElementById(\"stats_button\").addEventListener('click', function (ev) {\n    let settings_menu = document.getElementById(\"stats\");\n    if(document.gameManager.showStats == false) {\n        document.gameManager.updateStats();\n        document.gameManager.showStats = true;\n        settings_menu.classList.remove(\"hide\");\n        ev.target.setAttribute('aria-pressed', true);\n    } else {\n        document.gameManager.showStats = false;\n        settings_menu.classList.add(\"hide\");\n        ev.target.setAttribute('aria-pressed', false);\n    }    \n});\n\nlet sgs = document.getElementById(\"settings_game_size\");\nArray.prototype.forEach.call(sgs.children, (el) => {\n    el.addEventListener('click', function (ev) {\n        let s = Number.parseInt(el.getAttribute('data'));\n        document.gameManager.setSize(s,s);\n    });\n});\n\n\n;(function () {\n    function main(ts) {\n        document.gameManager.stopMain = window.requestAnimationFrame(main);\n        document.gameManager.render(ts);\n    }\n    main(0);\n})();\n\n\n//# sourceURL=webpack://pipehex/./index.js?");

/***/ }),

/***/ "./puzzles.js":
/*!********************!*\
  !*** ./puzzles.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n// puzzles for pipehex\n// title, puzzle_string (w,h,puz,sol)\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n\tPUZZLES: [ \n\t\t{ t:'Test Level 0 (5x5)', p:'5,5,15qIYMKKe8WYC49P6eA7WmAe4,25D9AoY5AG2Km4Io3e5S1OHeW' },\n\t\t{ t:'Test Level 0 (10x10)', p:'10,10,15eAYmuaa5SXC4QOc9K419ee4eXKmfPAGcHIImO12AaICIB1eYZXO9O8m93AW9meYK3CYeZCeC6A33XKGYAX65XAaYK6OYI34Hbm,25A5A6799AnCm4qmJ9AG2a5eW5CK3QoY1Deaa3OG2KIa6ab8HAnCmamW39CK2a3e5A3OYYnCKXCHO3OK2YY6XA3AIYHOmH9OGHPO' },\n\t\t{ t:'Test Level 0 (20x20)', p:'20,20,X9aIY89amYo1HD6YK66YBA9Cg9XYOmeY9mH33aI1YOCH1O3HeAA9KCYAq85959aHKa3C3A2C96ZHIXmKKY8aKaCHYH3fH2HYaHY559ImOIcYIYW9H6e2IGfn549I5Qm6AH5AX9u6a9eHAYYX62I8MAH6HG5XKAP86gH55HCaAm33A5HYQK8I63nee69IH5amKO8aHam3GM168aa2CIHXAAMI3AHBHIHKKqmIAna51ICIOOK86YHm3Og55Xa2JXa5XI6bOCXCeYCeeGaCQ9YeXI9KYq19IH3anIK5O5en99aHHa4HYeWe933a9eYHIC1K8OKKa66KGm9AemOH6XebJe9Ce5aeIOg34eI4g3XXY59aI93E89IeIAAHHHKeK99Iaaaa5mA49au4B9OW,3999A199C5B85DC5A63AM59CL9CYXCHeaXe6mIIGYm6YW6XAHe59e65eJ8KIKaIHeI3O3e1Cam7AIXCKYY2I59OHAHCcY1eKIHeYKIIm39DAIYWIHCY2I1DSY2II5QXCKKK5Oa7OIIYYKKKm6GaWbeY3eWHCKKMGXgY5eKX9e63OHA5ecYWI3OnAY399eKI3Am4aKI3O1P86GII1Ca5OKHiaXAKM59eHAJOaYZ9e4aX9CmYGXA5C3OLe5OI2cX9AX9CM6mXCKY3e58ImJ9AHCaaKYJ8aa5OIZ9AHCK5SaaaYKIWYY58KI3OaaYYYaX8KW6HAIm3e1OIYY3OKm65icH9OHAI59CLOGKa1gmXCYH9999On8aa59eY5AHAYH9999999eXe199u1P9OG' },\n\t],\n});\n\n\n//# sourceURL=webpack://pipehex/./puzzles.js?");

/***/ }),

/***/ "./storage.js":
/*!********************!*\
  !*** ./storage.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* Copyright 2022 David Atkinson */\r\n\r\nconst prefix = 'phex_';\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n\tsave: function(key,val) {\r\n\t\tlocalStorage.setItem('phex_'+key, val);\r\n\t},\r\n\tsaveInt: function(key,val) { this.save(key,val); },\r\n\tsaveStr: function(key,val) { this.save(key,val); },\r\n\tloadInt: function(key,def) {\r\n\t\tvar x = parseInt(localStorage.getItem('phex_'+key));\r\n\t\tif(isNaN(x)) return def;\r\n\t\treturn x;\r\n\t},\r\n\tloadStr: function(key,def) {\r\n\t\tlet r = localStorage.getItem('phex_'+key);\r\n\t\tif(r == null) return def;\r\n\t\treturn r;\r\n\t},\r\n\tsaveObj: function(key,val) {\r\n\t\tlocalStorage.setItem('phex_'+key, JSON.stringify(val));\r\n\t},\r\n\tloadObj: function(key,def) {\r\n\t\tvar o = localStorage.getItem('phex_'+key);\r\n\t\tif(o == null) return def;\r\n\t\treturn JSON.parse(o);\r\n\t},\r\n});\r\n\n\n//# sourceURL=webpack://pipehex/./storage.js?");

/***/ }),

/***/ "./view.js":
/*!*****************!*\
  !*** ./view.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PALETTE\": () => (/* binding */ PALETTE),\n/* harmony export */   \"PALETTE_SIZE\": () => (/* binding */ PALETTE_SIZE),\n/* harmony export */   \"View\": () => (/* binding */ View),\n/* harmony export */   \"palette_dark\": () => (/* binding */ palette_dark)\n/* harmony export */ });\n/* harmony import */ var _game_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-manager.js */ \"./game-manager.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ \"./storage.js\");\n/* Copyright 2022 David Atkinson */\n\n\n\nconst getRange = length => [...Array(length).keys()];\n\n\n/* Palette based on Munsell colors */\n\nconst mpalette_c8v7_names = [\n'5R', '10R', '5YR', '10YR', '5Y', '10Y', '5GY', '10GY', '5G', '10G',\n'5BG', '10BG', '5B', '10B', '5PB', '10PB', '5P', '10P', '5RP', '10RP'\n];\n\nconst mpalette_c8v7 = [ \n'#d99a94', '#da9d80', '#d4a46e', '#cbab5d', '#bfb351', '#b5b94e', '#a6bf5a', '#92c477', '#83c596', '#7ec4a5', \n'#79c3b6', '#77c0c8', '#7dbbd8', '#89b4e1', '#9aade4', '#aea4e2', '#bc9fd8', '#ca9ac8', '#cf98bf', '#d798a4'\n];\n// grey APPROXIMATELY a9a9a9\n\nconst PALETTE_SIZE = 13;\nconst PALETTE = ['#bbbbbb', '#f51a3c','#a92393','#623297','#0060b3','#0078c5','#02b2b5',\n\t'#24bb4e','#add73c','#ffdd00','#ffc110','#fc9b1e','#f97625',];\n\nconst palette_dark = ['#cd1031','#8e107c','#51227e','#025197','#0064a3','#009797',\n\t'#1a9b43','#8eb330','#e3c100','#d9a10f','#d68115','#d3621a',];\n\nconst drawMethods = ['img','canvas_ctx2d','manual_mask'];\n\nclass View {\n\tconstructor(gwidth, gheight) {\n\t\tthis.gameWidth = gwidth;\n\t\tthis.gameHeight = gheight;\n\t\tthis.container = document.getElementById('container');\n\t\t//this.scoreboard = document.getElementById('scoreboard');\n\t\tthis.drawMethod = 1;\n\t\tthis.alwaysRenderAll = 0;\n\t\tthis.canvasCache = new Map();\n\t\t\n/*\t\tthis.srcImage = new Image();   // Create new img element\n\t\tthis.srcImage.loading = \"eager\";\n\t\tthis.srcImage.addEventListener('load', function() {\n\t\t\tconsole.log(\"image loaded\"); \n\t\t\tdocument.gameManager.view.setUp(document.gameManager.game.puzzle_w, document.gameManager.game.puzzle_h);\n\t\t}); */\n\t\t\n\t\t// the resize event will need fixing so it redraws everything\n\t\t// i.e. gm.paintAll();\n\t\t/* window.addEventListener('resize', () => {\n\t\t\tthis.setUp(document.gameManager.game.puzzle_w, document.gameManager.game.puzzle_h);\n\t\t}); */\n\t\tthis.setUp(gwidth, gheight); // this function will start the image loading process\n\t}\n\n\tsetUp(gameWidth, gameHeight) {\t// gameWidth and gameHeight are in grid units\n\t\tconsole.log('setting up...')\n\n\t\tlet { width, height } = this.container.getBoundingClientRect();\n\t\theight = document.documentElement.clientHeight - 15; // override the above height estimate: 10px padding 2px border 3px unknown\n\n\t\tthis.unitOnScreenH = 64;\n\t\tthis.unitOnScreenVO = 48;\n\t\tthis.unitOnScreenW = 56;\n\t\t//this.unitOnScreen = Math.floor(Math.min( width / gameWidth,\theight / gameHeight ));\n\t\t//this.unitOnScreen = ( Math.floor(this.unitOnScreen / 4) * 4 );\t// canvas drawImage is crappy, reduce aliasing artifacts\n\t\t//if(this.unitOnScreen > 256) this.unitOnScreen = 256; // reducing aliasing artifacts - can also split src into individual sprites\n\t\t//console.log(\"screen unit:\", this.unitOnScreenW, \" \", this.unitOnScreenH, \" \", this.unitOnScreenVO);\n\n\t\t// Because ImageBitmap options & imageSmoothingQuality aren't yet widely supported, and OffscreenCanvas isn't widely supported,\n\t\t// we are using pre-sized images. we can scale down and it looks OK, but we can't scale up.\n\t\t// blocksizes 64, 128, 192, 256\n\t\t// we return because this method will get called again once the image is loaded\n\t\tif(this.srcBlockH != 64) {\n\t\t\tthis.srcBlockH = 64;\n\t\t\tthis.srcBlockW = 56;\n/*\t\t\tthis.srcImage.src = 'tiles_56x64.png';\n\t\t\tconsole.log('loading src image');\n\t\t\treturn; */\n\t\t}\n\n\t\t// remove the old canvas, if it exists\n\t\tconst [child] = this.container.children;\n\t\tif(child) {\n\t\t\tthis.container.removeChild(child);\n\t\t}\n\t\t\n\t\t// create a new canvas\n\t\tconst canvas = document.createElement('canvas');\n\t\tthis.container.appendChild(canvas);\n\t\tthis.context = canvas.getContext('2d');\n\t\tcanvas.setAttribute('width',gameWidth * this.unitOnScreenW + Math.floor(this.unitOnScreenW/2));\n\t\tcanvas.setAttribute('height',(gameHeight + 1) * this.unitOnScreenVO - (this.unitOnScreenH/2));\n\t\t//console.log('new canvas created');\n\t\t\n\t\t// render (update stats display) with current stats\n\t\tthis.renderStats();\n\t}\n\t\n\trenderImg(dx, dy, sx, sy) {\n\t\tsx = sx * this.srcBlockW;\n\t\tsy = sy * this.srcBlockH;\n\t\tif(dy%2==1) dx += 0.5;\n\t\t\n/*\t\tif(this.srcImage.complete && this.context) { */\n\t\tif(this.context) {\n\t\t\tthis.context.drawImage(this.srcImage,\n\t\t\t\tsx,sy,\n\t\t\t\tthis.srcBlockW,this.srcBlockH,\n\t\t\t\tMath.floor(this.unitOnScreenW * dx),\n\t\t\t\tthis.unitOnScreenVO * dy,\n\t\t\t\tthis.unitOnScreenW,this.unitOnScreenH);\n\t\t}\n\t\t\t\n\t}\n\t\n\trenderFromCanvas(srcCanvas, dx, dy) {\n\t\tif(dy%2==1) dx += 0.5;\n\t\tif(this.context) {\n\t\t\tthis.context.drawImage(srcCanvas, 0, 0, this.unitOnScreenW, this.unitOnScreenH,\n\t\t\t\tMath.floor(this.unitOnScreenW * dx),\n\t\t\t\tthis.unitOnScreenVO * dy,\n\t\t\t\tthis.unitOnScreenW,this.unitOnScreenH);\n\t\t}\n\t}\n\t\n\tgetHexCanvas(colorIdx = PALETTE_SIZE) {\n\t\tlet key = colorIdx+65536;\t// allowing 16 bits for line tile cache\n\t\tif(this.canvasCache.has(key)) {\n\t\t\treturn this.canvasCache.get(key);\n\t\t}\n\t\t\n\t\tlet canvas = document.createElement('canvas');\n\t\tlet ctx = canvas.getContext('2d');\n\t\tlet width = this.unitOnScreenW;\n\t\tlet height = this.unitOnScreenH;\n\t\tcanvas.setAttribute('width',width);\n\t\tcanvas.setAttribute('height',height);\n\t\t//this.unitOnScreenH = 64;\n\t\t//this.unitOnScreenVO = 48;\n\t\t//this.unitOnScreenW = 56;\n\t\tctx.clearRect(0,0,width,height);\n\t\tif(colorIdx == PALETTE_SIZE) ctx.fillStyle = '#333333';\n\t\telse if(colorIdx == PALETTE_SIZE+1) ctx.fillStyle = '#555555';\n\t\telse ctx.fillStyle = PALETTE[colorIdx];\n\t\tctx.strokeStyle = '#000000';\n\t\tctx.lineWidth = 1;\n\t\tctx.beginPath();\n\t\tctx.moveTo(width/2, 0);\n\t\tctx.lineTo(width, height/4);\n\t\tctx.lineTo(width, height*3/4);\n\t\tctx.lineTo(width/2, height);\n\t\tctx.lineTo(0, height*3/4);\n\t\tctx.lineTo(0, height/4);\n\t\tctx.lineTo(width/2, 0);\n\t\tctx.fill();\n\t\tctx.stroke();\n\n\t\t// cache the result\n\t\tthis.canvasCache.set(key,canvas);\n\t\treturn canvas;\n\t}\n\n\tgetLineCanvas(conns, colorIdx) {\n\t\t// Use 2d context line drawing functions.\n\n\t\t// check if it is in cache\n\t\t// create key\n\t\tlet key = 0;\n\t\tfor(let i=0;i<6;i++) {\n\t\t\tif(conns[i]) key |= 1 << i;\n\t\t}\n\t\tkey |= colorIdx << 6;\n\t\tif(this.canvasCache.has(key)) {\n\t\t\treturn this.canvasCache.get(key);\n\t\t}\n\n\t\tlet canvas = document.createElement('canvas');\n\t\tlet ctx = canvas.getContext('2d');\n\t\tlet width = this.unitOnScreenW;\n\t\tlet height = this.unitOnScreenH;\n\t\tcanvas.setAttribute('width',width);\n\t\tcanvas.setAttribute('height',height);\n\t\tctx.lineCap = 'butt';\n\t\tctx.lineJoin = 'bevel';\t\t\t\t\t// will this help with Safari-iOS ugly butts?\n\t\t//ctx.imageSmoothingQuality = 'high'; \n\t\tctx.clearRect(0,0,width,height);\n\t\tctx.fillStyle = PALETTE[colorIdx];\n\t\tctx.strokeStyle = PALETTE[colorIdx];\n\t\tctx.lineWidth = height / 8;\n\t\t// For each angle:\n\t\tlet count = 0;\n\t\tfor(let i=0; i<conns.length; i++) {\n\t\t\tif(!conns[i]) continue;\n\t\t\tcount++;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(width/2,height/2);\n\t\t\tlet dx = width/2;\n\t\t\tlet dy = height/2;\n\t\t\tif(i==0) dx = width;\n\t\t\telse if(i==1) { dy = height * 7 / 8; dx = width * 3 / 4; }\n\t\t\telse if(i==2) { dy = height * 7 / 8; dx = width * 1 / 4; }\n\t\t\telse if(i==3) dx = 0;\n\t\t\telse if(i==4) { dy = height * 1 / 8; dx = width * 1 / 4; }\n\t\t\telse if(i==5) { dy = height * 1 / 8; dx = width * 3 / 4; }\n\t\t\tctx.lineTo(dx,dy);\n\t\t\tctx.stroke();\n\t\t}\n\t\t// If it's a single, draw a larger hub circle\n\t\tlet r = height/16;\n\t\tif(count==1) r = height/8;\n\t\tctx.beginPath();\n\t\tctx.moveTo(width/2,height/2);\n\t\tctx.arc(width/2,height/2,r,0,2*Math.PI,true);\n\t\tctx.fill(); // automatically closes the path\n\n\t\t// cache the result\n\t\tthis.canvasCache.set(key,canvas);\n\n\t\treturn canvas;\n\t}\n\n\trenderStats(stats) {\n\t\tif(document.gameManager && document.gameManager.stats) {\n\t\t\tconst stats = document.gameManager.stats;\n\t\t\tdocument.getElementById('stats_size').innerHTML = stats.puztype;\n\t\t\tdocument.getElementById('stats_num').innerHTML = stats.num;\n\t\t\tdocument.getElementById('stats_best').innerHTML = stats.best;\n\t\t\tdocument.getElementById('stats_best3').innerHTML = stats.best3;\n\t\t\tdocument.getElementById('stats_best5').innerHTML = stats.best5;\n\t\t\tdocument.getElementById('stats_best10').innerHTML = stats.best10;\n\t\t}\n\t}\n\trender() {\n\t\tlet gm = document.gameManager;\n\t\tif(!gm) {\n\t\t\tconsole.log('view::render() called with no gamemanager initialised');\n\t\t\treturn;\n\t\t}\n\t\tif(!this.context) {\n\t\t\t//console.log('view::render() called with no context initialised');\n\t\t\treturn;\n\t\t}\n\t\tlet game = document.gameManager.game;\n\t\tlet ts = document.gameManager.game.ts;\n\t\t\n\t\tif(this.alwaysRenderAll || gm.game.winningAnimation.started) {\n\t\t\tgm.paintAll(); // will update gm.renderSet appropriately\n\t\t}\n\t\t\t\t\n\t\tfor (const idx of gm.renderSet) {\n\t\t\tconst [x,y] = gm.game.xy_from_idx(idx);\n\t\t\tif(this.drawMethod == 0) {\t// old draw method for using an image as a source\n\t\t\t\tthis.renderImg(x,y,0,0);\t\t// background hexagon\n\t\t\t\tthis.renderImg(x,y,game.grid[y][x].angle,game.grid[y][x].shape);\t// line shape\n\t\t\t} else if(this.drawMethod == 1) {\n\t\t\t\tlet hexCanvas = null;\n\t\t\t\tif(gm.game.winningAnimation.started) {\n\t\t\t\t\tlet palidx = Math.floor((ts - gm.game.winningAnimation.start_ts)/100) + x;\n\t\t\t\t\tpalidx = 1 + Math.floor(palidx)%(PALETTE_SIZE-2);\n\t\t\t\t\thexCanvas = this.getHexCanvas(palidx);\n\t\t\t\t} else if(gm.loopedSet.has(idx)) {\n\t\t\t\t\thexCanvas = this.getHexCanvas(PALETTE_SIZE+1);\n\t\t\t\t} else {\n\t\t\t\t\thexCanvas = this.getHexCanvas();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.renderFromCanvas(hexCanvas, x, y);\n\t\t\t\tlet colorIdx = gm.game.grid[y][x].color;\n\t\t\t\tlet srcCanvas = this.getLineCanvas(game.grid[y][x].conns,colorIdx);\n\t\t\t\tthis.renderFromCanvas(srcCanvas, x, y);\n\t\t\t} else {\n\t\t\t\t// unimplemented draw method\n\t\t\t}\n\t\t};\n\t\t\n\t\t// clear the render set, now we've rendered all the tiles\n\t\tgm.renderSet.clear();\n\t\t\n\t\t// update fps\n\t\tif(document.gameManager.showFPS) {\n\t\t\tlet fps = Math.floor(1000.0 / (ts - game.last_ts));\n\t\t\tdocument.getElementById(\"fps_text\").innerHTML = '' + fps;\n\t\t}\n\t\t\n\t\t// update cached timestamp\n\t\tgame.last_ts = ts;\n\n\t\t// update puzzle title\n\t\tdocument.getElementById(\"puzzle_title\").innerHTML = game.title;\n\t\t\n\t\t// update timer\n\t\tdocument.getElementById(\"timer_text\").innerHTML = game.timer.get_timestring(ts);\n\n\t\t// update win screen\n\t\tif(game.won) {\n\t\t\tdocument.getElementById('wintime').innerHTML = game.wintime;\n\t\t\tdocument.getElementById('winner').classList.remove('hide');\n\t\t\tthis.renderStats(gm.stats);\t// update statistics\n\t\t} else {\n\t\t\tdocument.getElementById(\"winner\").classList.add(\"hide\");\n\t\t}\n\t\t\n\t\t// update paused button\n\t\tconst paused = !document.gameManager.game.timer.running;\n\t\tdocument.getElementById('pause').setAttribute('aria-pressed', paused);\n\t}\n}\n\n\n//# sourceURL=webpack://pipehex/./view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;